---
title: "Linux下MySQL的安装与使用"
subtitle: "Linux下MySQL的安装与使用"
date: 2025-3-21 21:15:26
category:
  - MySQL
tag:
  - MySQL
order: 1
---
## 1、安装

### 1.1、docker安装MySQL

```shell
docker run -d \
-p 3309:3306 \
-v /atguigu/mysql/mysql8/conf:/etc/mysql/conf.d \
-v /atguigu/mysql/mysql8/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
--name atguigu-mysql8 \
--restart=always \
mysql:8.0.30
```

### 1.2、查看是否启动

```shell
docker ps
```

### 1.3、测试远程链接

**测试连接：**MySQL 8 版本，图形连接时还会出现如下问题

![image-20220625232225259](https://beauties.eu.org/blogimg/main/img1/image-20220625232225259.png)

配置新连接报错：错误号码 2058，出现这个错误的原因是MySQL 8 之前的版本中加密规则是**mysql_native_password**，而在MySQL 8之后，加密规则是**caching_sha2_password**。

**解决方案:**

- 方案一：升级SQLyog和Navicat（因此，新版SQLyog和Navicat不会出现此问题）

- 方案二：把MySQL用户登录密码加密规则还原成mysql_native_password。


登录你的 MySQL 数据库 登录你的 MySQL 数据库

```shell
#进入容器：env LANG=C.UTF-8 避免容器中显示中文乱码
docker exec -it atguigu-mysql8 env LANG=C.UTF-8 /bin/bash

#进入容器内的MySQL命令行
mysql -uroot -p

#修改默认密码校验方式
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
```

然后再重新配置SQLyog的连接，重新填写密码，则可连接成功了。

## 2、字符集

### 2.1、默认字符集

MySQL 8版本之前，默认字符集为 **latin1**（ISO-8859-1） ，不支持中文，使用前必须设置字符集为utf8。

从MySQL 8开始，数据库的默认字符集为 utf8 ，从而避免中文乱码的问题。

```shell
# 查看MySQL使用的字符集
SHOW VARIABLES LIKE '%char%';
```

### 2.2、utf8与utf8mb4

utf8 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而字符集表示一个字符所用的最大字节长度，在某些方面会影响系统的存储和性能，所以设计MySQL的设计者偷偷的定义了两个概念：

**utf8mb3** ：utf8mb3 阉割过的 utf8 字符集，只使用1～3个字节表示字符（无法存储emoji表情等特殊符号）。

**utf8mb4**：utf8mb4正宗的 utf8 字符集，使用1～4个字节表示字符。 

**注意：**MySQL5.7中的utf8是utf8mb3字符集 , MySQL8.0中的utf8是utf8mb4字符集

## 3、 SQL大小写规范

### 3.1、Windows和Linux的区别 

**Windows环境：**全部不区分大小写

**Linux环境：**

1、数据库名、表名、表的别名严格区分大小写；

```sql
-- 1.创建数据库和表：
CREATE DATABASE MyDatabase;
USE MyDatabase;
CREATE TABLE MyTable (id INT, name VARCHAR(50));
-- 在此示例中，"MyDatabase" 是数据库名，"MyTable" 是表名，它们的大小写必须完全匹配。

-- 2.查询语句：
SELECT id, name FROM MyTable;
-- 在这个查询语句中，"MyTable" 是表名，它的大小写必须与之前创建表时的一致。如果表名为 "mytable" 或者 "MYTABLE"，将会引发错误。

-- 3.别名：
SELECT t.id, t.name FROM MyTable AS t;
-- 在这个示例中，使用了表的别名 "t"，使用别名t时，任何位置的大小写要一致。
```

2、列名与列的别名不区分大小写;

```sql
SELECT id AS ID, name as Name FROM MyTable where id = 2;
-- "ID" 和 "Name" 是列的别名，它们的大小写是可以忽略的。也就是说，可以使用大小写任意组合，例如 "id"、"ID" 或 "Id" 都可以正确引用相同的列。

-- 同样地，原始列名 "id" 和 "name" 不区分大小写，因此下面的查询是等效的：
SELECT id, name FROM MyTable;
SELECT ID, Name FROM MyTable;
```

3、关键字、函数名称不区分大小写；

```sql
SELECT * FROM mytable WHERE id = 1;
-- 在这个示例中，"SELECT"、"FROM" 和 "WHERE" 是SQL查询语句中的关键字，它们的大小写是可以忽略的。也就是说，可以使用大小写任意组合，例如 "select"、"Select" 或 "SELECT" 都可以正确解析相同的查询。

-- 同样地，MySQL内置的函数名也不区分大小写。例如，下面的查询将调用 UPPER 函数，无论其大小写如何：
SELECT UPPER(name) FROM mytable;
SELECT upper(name) FROM mytable;
SELECT UpPeR(name) FROM mytable;
```

4、变量名不区分大小写;

```sql
SET @myVariable = 42;
SELECT @myVariable;
SELECT @MyVariable;
-- 在这个示例中，变量名不区分大小写，以上两个查询都是有效的sql语句
```

### 3.2、Linux下大小写规则设置（了解）

在MySQL 8中设置的具体步骤为：

```
1、停止MySQL服务 
2、删除数据目录，即删除 /var/lib/mysql 目录 
3、在MySQL配置文件（/etc/my.cnf ）的 [mysqld] 中添加 lower_case_table_names=1 
4、初始化数据目录 mysqld --initialize --user=mysql
5、启动MySQL服务 systemctl start mysqld
```

**注意：不建议在开发过程中修改此参数，将会丢失所有数据**

## 4、sql_mode

### 4.1、宽松模式 vs 严格模式

MySQL有两种模式：宽松模式（Loose Mode）和严格模式（Strict Mode）。这些模式决定了MySQL在处理数据时的行为和规则。

**宽松模（Loose Mode）：**

执行错误的SQL或插入不规范的数据，也会被接受，并且不报错。

**严格模式（Strict Mode）：**

执行错误的SQL或插入不规范的数据，会报错。MySQL5.7版本开始就将sql_mode默认值设置为了严格模式。

### 4.2、查看和设置sql_mode

**查询sql_mode的值：**

```sql
SHOW VARIABLES LIKE 'sql_mode';
```

![image-20220627032313938](https://beauties.eu.org/blogimg/main/img1/image-20220627032313938.png)

**临时设置sql_mode的值：**

```sql
SET sql_mode = 'mode1,model2,...'; --当前会话生效效，关闭当前会话就不生效了
```

### 4.3、错误开发演示 

**建表并插入数据：**

```sql
CREATE DATABASE atguigudb;
USE atguigudb;
CREATE TABLE employee(id INT, `name` VARCHAR(16),age INT,dept INT);
INSERT INTO employee VALUES(1,'zhang3',33,101);
INSERT INTO employee VALUES(2,'li4',34,101);
INSERT INTO employee VALUES(3,'wang5',34,102);
INSERT INTO employee VALUES(4,'zhao6',34,102);
INSERT INTO employee VALUES(5,'tian7',36,102);
```

**需求：查询每个部门年龄最大的人**

```sql
-- 错误演示
SELECT `name`, dept, MAX(age) FROM employee GROUP BY dept; 
```

以上查询语句在 “`ONLY_FULL_GROUP_BY`” 模式下查询出错，因为select子句中的name列并没有出现在group by子句中，也没有出现在函数中：

![image-20220627033533410](https://beauties.eu.org/blogimg/main/img1/image-20220627033533410.png)

在非 “ONLY_FULL_GROUP_BY” 模式下可以正常执行，但是得到的是错误的结果：

```sqlite
SET sql_mode = ''; 
```

![image-20220627033754883](https://beauties.eu.org/blogimg/main/img1/image-20220627033754883.png)

**正确的查询方式：查询应该分两个步骤**

1、查询每个部门最大的年龄

2、查询人

正确的语句：

```sql
SELECT e.* 
FROM employee e
INNER JOIN (SELECT dept, MAX(age) age FROM employee GROUP BY dept) AS maxage 
ON e.dept = maxage.dept AND e.age = maxage.age;
```

**测试完成后再将sql_mode设置回来：**

```sqlite
SET SESSION sql_mode = 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
```

### 4.4、sql_mode常用值（了解）

- `ONLY_FULL_GROUP_BY：`对于GROUP BY聚合操作，SELECT子句中只能包含函数和 GROUP BY 中出现的字段。
- STRICT_TRANS_TABLES：
  - 对于支持事务的表，如果发现某个值缺失或非法，MySQL将抛出错误，语句会停止运行并回滚。
  - 对于不支持事务的表，不做限制，提高性能。
- `NO_ZERO_IN_DATE`：不允许`日期`和`月份`为零。
- `NO_ZERO_DATE`：MySQL数据库不允许插入零日期，插入零日期会抛出错误而不是警告。
- ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULL。
- NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或不存在，那么抛出错误。不设置此值时，用默认的存储引擎替代。

