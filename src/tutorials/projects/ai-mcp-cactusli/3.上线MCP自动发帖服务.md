---
title: "上线MCP自动发帖服务"
subtitle: "上线MCP自动发帖服务"
date: 2024-7-16 10:54:20
category:
  - MCP
tag:
  - MCP
order: 3
---
## 一、介绍

本章会以 Jar 包的形式，打包 MCP 自动发帖服务，并以 stdio 方式引入到项目工程。再通过定时任务触达定时自动发帖。

## 二、流程梳理

如图，以 stdio 方式，构建服务打包上线；

![上线MCP自动发帖服务.drawio](https://beauties.eu.org/blogimg/main/img1/上线MCP自动发帖服务.drawio.png)

* 第一步，将 mcp-server-csdn 以 maven 命令方式打一个 jar，IntelliJ IDEA 也可以直接通过界面操作打包 Jar。
* 第二步， 以 maven 命令方式，将 ai-mcp-cactusli打一个 jar，并执行 Dockerfile 构建出可部署的镜像。
* 第三步，通过 docker-compose 脚本配置上线部署。

## 三、服务实现

首先，在项目部署前，我们要先增加一个 trigger 模块，在这个模块下添加 job 任务。定时的调用 ai mcp 服务，进行文章的编写和发布。

**注意：**发布失败后，排查 cookie 是否失效！

### 1. 项目结构

![image-20250624164318931](https://beauties.eu.org/blogimg/main/img1/image-20250624164318931.png)

* 首先，增加了 trigger 模块，提供了执行任务。这个任务可以按需配置多个，分别执行不同时间的不同类型文章编写。
* 之后，项目所需的 chatClient 收到了 OpenAIConfig 中进行构建，这部分注意下代码就可以。只是挪动位置，代码没有变化。
* 最后，build.sh、Dockerfile、push.sh，tag 下的文件，都是为了项目从构建到部署上线的。

### 2. 定时任务

#### 2.1 配置对话客户端

```java
@Configuration
public class OpenAIConfig {


    @Bean
    public ChatClient.Builder chatClientBuilder(OpenAiChatModel openAiChatModel, @Qualifier("tools") ToolCallbackProvider tools) {
        DefaultChatClientBuilder defaultChatClientBuilder = new DefaultChatClientBuilder(openAiChatModel, ObservationRegistry.NOOP, (ChatClientObservationConvention) null);
        return defaultChatClientBuilder.defaultToolCallbacks(tools)
                .defaultOptions(OpenAiChatOptions.builder()
                        .model("gpt-4o")
                        .build());
    }

}

```

#### 2.2 定时任务

```java
/**
 * Package: cn.cactusli.trigger
 * Description:
 *
 * @Author 仙人球⁶ᴳ |
 * @Date 2025/6/24 15:32
 * @Github https://github.com/lixuanfengs
 */
@Slf4j
@Service
public class MCPServerCSDNJob {

    @Resource
    private ChatClient chatClient;

    @Scheduled(cron = "0 0 * * * ?")
    public void execute() {
        // 检查当前时间是否在指定的时间段内（8点到23点之间）
        int hour = java.time.LocalTime.now().getHour();
        if (hour < 8 || hour >= 23) {
            log.info("当前时间 {}点 不在任务执行时间范围内，跳过执行", hour);
            return;
        }
        try {
            String userInput = """
                    我需要你帮我生成一篇文章，要求如下；
                    
                    请根据以下要求生成一篇技术文章，并完成相关发布和通知任务：
                    文章要求
                   
                    1. 场景：互联网大厂 Java 求职者面试，聚焦真实业务场景下的技术应用。
                    2. 技术栈（精选核心技术，覆盖广泛但避免冗余）：
                       核心语言与平台：Java SE (8/11/17/21/23), JVM, Jakarta EE
                       构建工具：Maven, Gradle
                       Web 框架：Spring Boot, Spring MVC, Spring WebFlux, Quarkus
                       数据库与 ORM：Hibernate, MyBatis, Spring Data JPA, HikariCP, Flyway
                       测试框架：JUnit 5, Mockito, AssertJ, Cucumber
                       微服务与云原生：Spring Cloud, Eureka, Kubernetes, Resilience4j, OpenFeign
                       安全框架：Spring Security, JWT, OAuth2
                       消息队列：Kafka, RabbitMQ, Redis Pub/Sub
                       缓存技术：Redis, Caffeine, Spring Cache
                       日志与监控：Logback, SLF4J, Prometheus, Grafana, Micrometer, Jaeger
                       API 工具：Swagger/OpenAPI, Spring HATEOAS
                       CI/CD：Jenkins, GitLab CI, Docker, Kubernetes
                       AI 技术：Spring AI, RAG（检索增强生成）, 向量数据库（Milvus/Chroma）, Embedding 模型（OpenAI/Ollama）, 语义检索
                       其他：Lombok, MapStruct, WebSocket
                                    
                    3. 业务场景（精选高频场景，突出技术应用）：
                       音视频服务、内容社区（UGC/AIGC）、电商平台、本地生活服务、支付与金融、在线教育、智慧物流、广告与营销
                    4. 叙述风格：
                       以严肃的面试官和幽默的“水货程序员”谢飞机为主角，通过对话展现面试过程。
                       谢飞机能较好回答基础问题，面试官会适当夸赞并引导；对于复杂问题，谢飞机回答模糊，面试官循序渐进追问。
                       每轮面试包含 3-5 个问题，共 3 轮，问题之间有技术与业务场景的逻辑衔接，逐步深入。
                       面试结束时，面试官使用“回家等通知”类似话术。
                    5. 文章结构：
                       正文：以故事形式呈现面试对话，突出技术点与业务场景的结合。
                       答案解析：文章末尾详细解答每个问题，包含业务场景、技术实现细节及代码示例，确保小白也能理解。
                    6. 输出内容：
                       文章标题：包含核心技术点，如“Java 面试实战：Spring Boot 与 Kafka 在电商场景的应用”。
                       文章内容：完整的 Markdown 格式文章，包含面试对话和答案解析。
                       
                    文章标签：多个相关技术关键词，用英文逗号分隔，如 Java, Spring Boot, Kafka, 面试。
                    
                    发布与通知
                        发布平台：将文章发布至 CSDN，获取文章的 HTTP URL。
                        微信公众号通知：
                        平台：CSDN
                        主题：文章标题
                        描述：文章简述
                        跳转地址：CSDN 文章的 HTTP URL
                        
                    注意事项:
                        1. 请确保文章内容符合 CSDN 的发布规定，避免侵权和不当内容。
                        2. 确保技术点与业务场景结合紧密，问题设计具有递进性和实际意义。
                        3. 请在文章末尾提供参考文献或相关链接，以供读者进一步学习。
                        4. 请在文章中包含适当的版权声明和转载说明。
                        5. 发布和通知内容需准确无误，跳转地址有效。
                    """;

            log.info("执行结果:{} {}", userInput, chatClient.prompt(userInput).call().content());

        } catch (Exception e) {
            log.error("执行 MCP 自动发帖任务失败", e);
        }
    }
}
```

**注意：**`@Scheduled(cron = "0 0 * * * ?")` 是每个1小时执行1次，在测试验证阶段，可以配置时间稍微快一些，如10分钟1次。

### 3. 服务配置

![image-20250625153549026](https://beauties.eu.org/blogimg/main/img1/image-20250625153549026.png)

* 第一步，先把 `mcp-server-csdn` 进行打包 `install` 到本地仓库，拿到jar的路径。之后在你的 `ai-mcp-cactusli-app` 下配置 jar 的路径。这里的配置，是为你让你可以在本地验证运行。注意 `cookie` 要调整为你自己的。

* 第二步，在`ai-mcp-cactusli-app` 中 config 路径下配置 `mcp`, application-dev.yml 文件里配置上该路径。

## 四、服务上线

目前如果本地模型地址配置是可用的，那么就可以修改 cookie 为自己的，把环境脚本上传至服务器，启动执行就可以完成启动了。

### 1. 打包镜像

![image-20250625161252219](https://beauties.eu.org/blogimg/main/img1/image-20250625161252219.png)

* 参考上图进行服务的部署。

### 2. Docker Engine API 方式打包

在安装了 docker 服务的Linux中执行以下操作：

```shell
vim  /usr/lib/systemd/system/docker.service

[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target nss-lookup.target docker.socket firewalld.service containerd.service time-set.target
Wants=network-online.target containerd.service
Requires=docker.socket

[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker


# 添加 IP 和端口
#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
ExecStart=/usr/bin/dockerd -H tcp://192.168.1.23:4560 -H fd:// --containerd=/run/containerd/containerd.sock
ExecReload=/bin/kill -s HUP $MAINPID
TimeoutStartSec=0
RestartSec=2
Restart=always



# Note that StartLimit* options were moved from "Service" to "Unit" in systemd 229.
# Both the old, and new location are accepted by systemd 229 and up, so using the old location
# to make them work for either version of systemd.
StartLimitBurst=3

# Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.
# Both the old, and new name are accepted by systemd 230 and up, so using the old name to make
# this option work for either version of systemd.
StartLimitInterval=60s

# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNPROC=infinity
LimitCORE=infinity

# Comment TasksMax if your systemd version does not support it.
# Only systemd 226 and above support this option.
TasksMax=infinity

# set delegate yes so that systemd does not reset the cgroups of docker containers
Delegate=yes

# kill only the docker process, not all processes in the cgroup
KillMode=process
OOMScoreAdjust=-500

[Install]
WantedBy=multi-user.target

```

重启 Docker 服务:

```shell
sudo systemctl restart docker
```

配置防火墙限制访问:

```shell
# 只允许某个 Ip 能访问此端口
sudo iptables -A INPUT -p tcp --dport 2375 -s 192.168.1.218 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 2375 -j DROP

# 把规则持久化到文件里
sudo apt-get update
sudo apt-get install iptables-persistent

sudo iptables-save > /etc/iptables/rules.v4

sudo reboot

sudo iptables -L -v -n
```

在插件市场安装  docker 插件。

测试连接：

![image-20250625170101363](https://beauties.eu.org/blogimg/main/img1/image-20250625170101363.png)

![image-20250625170336725](https://beauties.eu.org/blogimg/main/img1/image-20250625170336725.png)

![image-20250625171620708](https://beauties.eu.org/blogimg/main/img1/image-20250625171620708.png)

如图镜像打包成功。

### 3. 推送镜像

推送镜像到 Docker hub：

```shell
root@rag-host:/home/cactusli# docker login
Authenticating with existing credentials... [Username: ****]

i Info → To login with a different account, run 'docker logout' followed by 'docker login'


Login Succeeded
root@rag-host:/home/cactusli# docker push cactuslixf/ai-mcp-cactusli-app:1.0
The push refers to repository [docker.io/cactuslixf/ai-mcp-cactusli-app]
6b33e6e747e1: Pushed
abb34ab69cf0: Pushed
6be690267e47: Mounted from cactuslixf/ai-rag-knowledge-app
13a34b6fff78: Mounted from cactuslixf/ai-rag-knowledge-app
9c1b6dd6c1e6: Mounted from cactuslixf/ai-rag-knowledge-app
1.0: digest: sha256:1bcd706275bebe2025095c0aa5041edb2647eb2cde28608a765dd72a512b93cb size: 1372
```

![image-20250625172208627](https://beauties.eu.org/blogimg/main/img1/image-20250625172208627.png)

> 注意别忘记开启代理！！！

也可以执行 push 脚本：

![image-20250625172831426](https://beauties.eu.org/blogimg/main/img1/image-20250625172831426.png)

### 4. 环境脚本

![image-20250625173338167](https://beauties.eu.org/blogimg/main/img1/image-20250625173338167.png)

* 环境部署，需要先通过 docker-compose 安装环境。redis、pg库等。

### 5. 项目脚本

![image-20250625174809197](https://beauties.eu.org/blogimg/main/img1/image-20250625174809197.png)

* 1.将 `mcp-server-csdn` 打包好的 jar 放到此路径下
* 2.在服务器上使用 `docker-compose -f docker-compose-app-v1.0.yml up -d` 启动服务
* 3.以docker 挂载目录的方式，指定 jar 所在的位置
* 4.在这映射的是外部地址，需要改为 file 地址
* 5.指定 mcp 使用到jar 的所在地址。

### 6. 服务部署启动

#### 6.1 上传脚本

![image-20250626153323939](https://beauties.eu.org/blogimg/main/img1/image-20250626153323939.png)

#### 6.2 执行脚本

![image-20250630175323337](https://beauties.eu.org/blogimg/main/img1/image-20250630175323337.png)

* 在指定目录下运行命令
  * `docker compose -f docker-compose-environment.yml up -d`
  * `docker compose -f docker-compose-app-v1.0.yml up -d` 

- 执行完命令后，服务就会给自动的给 CSDN 发帖了。
