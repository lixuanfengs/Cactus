import{_ as l,o as e,c as a,h as i}from"./app-BcEKNYdX.js";const n={},t=i(`<blockquote><p>本文对JVM涉及的常见的调优参数和垃圾回收参数进行阐述。</p></blockquote><ul><li>调试排错之 JVM 调优参数 <ul><li><a href="#jvm%E5%8F%82%E6%95%B0">jvm参数</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">垃圾回收</a></li></ul></li></ul><h3 id="jvm参数" tabindex="-1"><a class="header-anchor" href="#jvm参数"><span><a href="#jvm%E5%8F%82%E6%95%B0">#</a> jvm参数</span></a></h3><ul><li>-Xms</li></ul><p>堆最小值</p><ul><li>-Xmx</li></ul><p>堆最大堆值。-Xms与-Xmx 的单位默认字节都是以k、m做单位的。</p><p>通常这两个配置参数相等，避免每次空间不足，动态扩容带来的影响。</p><ul><li>-Xmn</li></ul><p>新生代大小</p><ul><li>-Xss</li></ul><p>每个线程池的堆栈大小。在jdk5以上的版本，每个线程堆栈大小为1m，jdk5以前的版本是每个线程池大小为256k。一般在相同物理内存下，如果减少－xss值会产生更大的线程数，但不同的操作系统对进程内线程数是有限制的，是不能无限生成。</p><ul><li>-XX:NewRatio</li></ul><p>设置新生代与老年代比值，-XX:NewRatio=4 表示新生代与老年代所占比例为1:4 ，新生代占比整个堆的五分之一。如果设置了-Xmn的情况下，该参数是不需要在设置的。</p><ul><li>-XX:PermSize</li></ul><p>设置持久代初始值，默认是物理内存的六十四分之一</p><ul><li>-XX:MaxPermSize</li></ul><p>设置持久代最大值，默认是物理内存的四分之一</p><ul><li>-XX:MaxTenuringThreshold</li></ul><p>新生代中对象存活次数，默认15。(若对象在eden区，经历一次MinorGC后还活着，则被移动到Survior区，年龄加1。以后，对象每次经历MinorGC，年龄都加1。达到阀值，则移入老年代)</p><ul><li>-XX:SurvivorRatio</li></ul><p>Eden区与Subrvivor区大小的比值，如果设置为8，两个Subrvivor区与一个Eden区的比值为2:8，一个Survivor区占整个新生代的十分之一</p><ul><li>-XX:+UseFastAccessorMethods</li></ul><p>原始类型快速优化</p><ul><li>-XX:+AggressiveOpts</li></ul><p>编译速度加快</p><ul><li>-XX:PretenureSizeThreshold</li></ul><p>对象超过多大值时直接在老年代中分配</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span>说明: </span></span>
<span class="line"><span>整个堆大小的计算公式: JVM 堆大小 ＝ 年轻代大小＋年老代大小＋持久代大小。</span></span>
<span class="line"><span>增大新生代大小就会减少对应的年老代大小，设置-Xmn值对系统性能影响较大，所以如果设置新生代大小的调整，则需要严格的测试调整。而新生代是用来存放新创建的对象，大小是随着堆大小增大和减少而有相应的变化，默认值是保持堆大小的十五分之一，-Xmn参数就是设置新生代的大小，也可以通过-XX:NewRatio来设置新生代与年老代的比例，java 官方推荐配置为3:8。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>新生代的特点就是内存中的对象更新速度快，在短时间内容易产生大量的无用对象，如果在这个参数时就需要考虑垃圾回收器设置参数也需要调整。推荐使用: 复制清除算法和并行收集器进行垃圾回收，而新生代的垃圾回收叫做初级回收。</span></span>
<span class="line"><span>StackOverflowError和OutOfMemoryException。当线程中的请求的栈的深度大于最大可用深度，就会抛出前者；若内存空间不够，无法创建新的线程，则会抛出后者。栈的大小直接决定了函数的调用最大深度，栈越大，函数嵌套可调用次数就越多。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>经验</strong> :</p><ol><li>Xmn用于设置新生代的大小。过小会增加Minor GC频率，过大会减小老年代的大小。一般设为整个堆空间的1/4或1/3.</li><li>XX:SurvivorRatio用于设置新生代中survivor空间(from/to)和eden空间的大小比例； XX:TargetSurvivorRatio表示，当经历Minor GC后，survivor空间占有量(百分比)超过它的时候，就会压缩进入老年代(当然，如果survivor空间不够，则直接进入老年代)。默认值为50%。</li><li>为了性能考虑，一开始尽量将新生代对象留在新生代，避免新生的大对象直接进入老年代。因为新生对象大部分都是短期的，这就造成了老年代的内存浪费，并且回收代价也高(Full GC发生在老年代和方法区Perm).</li><li>当Xms=Xmx，可以使得堆相对稳定，避免不停震荡</li><li>一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少<strong>动态类</strong>的产生。</li></ol><h3 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收"><span><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">#</a> 垃圾回收</span></a></h3><p><strong>垃圾回收算法</strong> :</p><ul><li>引用计数法: 会有循环引用的问题，古老的方法；</li><li>Mark-Sweep: 标记清除。根可达判断，最大的问题是空间碎片(清除垃圾之后剩下不连续的内存空间)；</li><li>Copying: 复制算法。对于短命对象来说有用，否则需要复制大量的对象，效率低。<strong>如Java的新生代堆空间中就是使用了它(survivor空间的from和to区)；</strong></li><li>Mark-Compact: 标记整理。对于老年对象来说有用，无需复制，不会产生内存碎片</li></ul><p><strong>GC考虑的指标</strong></p><ul><li>吞吐量: 应用耗时和实际耗时的比值；</li><li>停顿时间: 垃圾回收的时候，由于Stop the World，应用程序的所有线程会挂起，造成应用停顿。</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span>吞吐量和停顿时间是互斥的。</span></span>
<span class="line"><span>对于后端服务(比如后台计算任务)，吞吐量优先考虑(并行垃圾回收)；</span></span>
<span class="line"><span>对于前端应用，RT响应时间优先考虑，减少垃圾收集时的停顿时间，适用场景是Web系统(并发垃圾回收)</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>回收器的JVM参数</strong></p><ul><li>-XX:+UseSerialGC</li></ul><p>串行垃圾回收，现在基本很少使用。</p><ul><li>-XX:+UseParNewGC</li></ul><p>新生代使用并行，老年代使用串行；</p><ul><li>-XX:+UseConcMarkSweepGC</li></ul><p>新生代使用并行，老年代使用CMS(一般都是使用这种方式)，CMS是Concurrent Mark Sweep的缩写，并发标记清除，一看就是老年代的算法，所以，它可以作为老年代的垃圾回收器。CMS不是独占式的，它关注停顿时间</p><ul><li>-XX:ParallelGCThreads</li></ul><p>指定并行的垃圾回收线程的数量，最好等于CPU数量</p><ul><li>-XX:+DisableExplicitGC</li></ul><p>禁用System.gc()，因为它会触发Full GC，这是很浪费性能的，JVM会在需要GC的时候自己触发GC。</p><ul><li>-XX:CMSFullGCsBeforeCompaction</li></ul><p>在多少次GC后进行内存压缩，这个是因为并行收集器不对内存空间进行压缩的，所以运行一段时间后会产生很多碎片，使得运行效率降低。</p><ul><li>-XX:+CMSParallelRemarkEnabled</li></ul><p>降低标记停顿</p><ul><li>-XX:+UseCMSCompactAtFullCollection</li></ul><p>在每一次Full GC时对老年代区域碎片整理，因为CMS是不会移动内存的，因此会非常容易出现碎片导致内存不够用的</p><ul><li>-XX:+UseCmsInitiatingOccupancyOnly</li></ul><p>使用手动触发或者自定义触发cms 收集，同时也会禁止hostspot 自行触发CMS GC</p><ul><li>-XX:CMSInitiatingOccupancyFraction</li></ul><p>使用CMS作为垃圾回收，使用70%后开始CMS收集</p><ul><li>-XX:CMSInitiatingPermOccupancyFraction</li></ul><p>设置perm gen使用达到多少％比时触发垃圾回收，默认是92%</p><ul><li>-XX:+CMSIncrementalMode</li></ul><p>设置为增量模式</p><ul><li>-XX:+CmsClassUnloadingEnabled</li></ul><p>CMS是不会默认对永久代进行垃圾回收的，设置此参数则是开启</p><ul><li>-XX:+PrintGCDetails</li></ul><p>开启详细GC日志模式，日志的格式是和所使用的算法有关</p><ul><li>-XX:+PrintGCDateStamps</li></ul><p>将时间和日期也加入到GC日志中</p>`,68),s=[t];function r(p,o){return e(),a("div",null,s)}const c=l(n,[["render",r],["__file","调试排错 JVM 调优参数.html.vue"]]),m=JSON.parse(`{"path":"/posts/Java/JVM/%E8%B0%83%E8%AF%95%E6%8E%92%E9%94%99%20JVM%20%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0.html","title":"调试排错之 JVM 调优参数","lang":"zh-CN","frontmatter":{"title":"调试排错之 JVM 调优参数","subtitle":"Java，Java开发，Java 体系","date":"2024-03-17T17:08:41.000Z","category":["Java"],"tag":["Java","JVM"],"order":12,"description":"本文对JVM涉及的常见的调优参数和垃圾回收参数进行阐述。 调试排错之 JVM 调优参数 jvm参数 垃圾回收 # jvm参数 -Xms 堆最小值 -Xmx 堆最大堆值。-Xms与-Xmx 的单位默认字节都是以k、m做单位的。 通常这两个配置参数相等，避免每次空间不足，动态扩容带来的影响。 -Xmn 新生代大小 -Xss 每个线程池的堆栈大小。在jdk5...","head":[["meta",{"property":"og:url","content":"https://cactusli.net/posts/Java/JVM/%E8%B0%83%E8%AF%95%E6%8E%92%E9%94%99%20JVM%20%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Cactus's Blog"}],["meta",{"property":"og:title","content":"调试排错之 JVM 调优参数"}],["meta",{"property":"og:description","content":"本文对JVM涉及的常见的调优参数和垃圾回收参数进行阐述。 调试排错之 JVM 调优参数 jvm参数 垃圾回收 # jvm参数 -Xms 堆最小值 -Xmx 堆最大堆值。-Xms与-Xmx 的单位默认字节都是以k、m做单位的。 通常这两个配置参数相等，避免每次空间不足，动态扩容带来的影响。 -Xmn 新生代大小 -Xss 每个线程池的堆栈大小。在jdk5..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-22T10:01:39.000Z"}],["meta",{"property":"article:author","content":"Cactus li"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2024-03-17T17:08:41.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-22T10:01:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"调试排错之 JVM 调优参数\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-17T17:08:41.000Z\\",\\"dateModified\\":\\"2024-03-22T10:01:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cactus li\\",\\"url\\":\\"https://cactusli.net\\"}]}"]]},"headers":[{"level":3,"title":"# jvm参数","slug":"jvm参数","link":"#jvm参数","children":[]},{"level":3,"title":"# 垃圾回收","slug":"垃圾回收","link":"#垃圾回收","children":[]}],"git":{"createdTime":1710139794000,"updatedTime":1711101699000,"contributors":[{"name":"lixuanfengs","email":"1183895890@qq.com","commits":2}]},"readingTime":{"minutes":6.35,"words":1905},"filePathRelative":"posts/Java/JVM/调试排错 JVM 调优参数.md","localizedDate":"2024年3月17日","excerpt":"<blockquote>\\n<p>本文对JVM涉及的常见的调优参数和垃圾回收参数进行阐述。</p>\\n</blockquote>\\n<ul>\\n<li>调试排错之 JVM 调优参数\\n<ul>\\n<li><a href=\\"#jvm%E5%8F%82%E6%95%B0\\">jvm参数</a></li>\\n<li><a href=\\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\\">垃圾回收</a></li>\\n</ul>\\n</li>\\n</ul>\\n<h3><a class=\\"header-anchor\\" href=\\"#jvm参数\\"><span></span></a><a href=\\"#jvm%E5%8F%82%E6%95%B0\\">#</a> jvm参数</h3>","autoDesc":true}`);export{c as comp,m as data};
