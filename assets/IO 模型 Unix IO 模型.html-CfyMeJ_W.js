import{_ as i,o as a,c as l,h as e}from"./app-B2NamrPB.js";const n={},o=e(`<blockquote><p>本文主要简要介绍 Unix I/O 5种模型，并对5大模型比较，并重点为后续章节解释IO多路复用做铺垫。</p></blockquote><ul><li>IO 模型 Unix IO 模型 <ul><li>Unix IO 模型简介 <ul><li><a href="#%E9%98%BB%E5%A1%9E%E5%BC%8F-io">阻塞式 I/O</a></li><li><a href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-io">非阻塞式 I/O</a></li><li><a href="#io-%E5%A4%8D%E7%94%A8">I/O 复用</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-io">信号驱动 I/O</a></li><li><a href="#%E5%BC%82%E6%AD%A5-io">异步 I/O</a></li></ul></li><li>I/O 模型比较 <ul><li><a href="#%E5%90%8C%E6%AD%A5-io-%E4%B8%8E%E5%BC%82%E6%AD%A5-io">同步 I/O 与异步 I/O</a></li><li><a href="#%E4%BA%94%E5%A4%A7-io-%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83">五大 I/O 模型比较</a></li></ul></li><li>IO多路复用 <ul><li>IO多路复用工作模式 <ul><li><a href="#1-lt-%E6%A8%A1%E5%BC%8F">1. LT 模式</a></li><li><a href="#2-et-%E6%A8%A1%E5%BC%8F">2. ET 模式</a></li></ul></li><li>应用场景 <ul><li><a href="#1-select-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1. select 应用场景</a></li><li><a href="#2-poll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">2. poll 应用场景</a></li><li><a href="#3-epoll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">3. epoll 应用场景</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><h2 id="unix-io-模型简介" tabindex="-1"><a class="header-anchor" href="#unix-io-模型简介"><span><a href="#unix-io-%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B">#</a> Unix IO 模型简介</span></a></h2><p>一个输入操作通常包括两个阶段:</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 下有五种 I/O 模型:</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用(select 和 poll)</li><li>信号驱动式 I/O(SIGIO)</li><li>异步 I/O(AIO)</li></ul><h3 id="阻塞式-i-o" tabindex="-1"><a class="header-anchor" href="#阻塞式-i-o"><span><a href="#%E9%98%BB%E5%A1%9E%E5%BC%8F-i-o">#</a> 阻塞式 I/O</span></a></h3><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p>下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">ssize_t</span><span style="color:#61AFEF;"> recvfrom</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;font-style:italic;"> sockfd</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> void</span><span style="color:#C678DD;"> *</span><span style="color:#E06C75;font-style:italic;">buf</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> size_t</span><span style="color:#E06C75;font-style:italic;"> len</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;font-style:italic;"> flags</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> struct</span><span style="color:#E06C75;"> sockaddr </span><span style="color:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;">src_addr</span><span style="color:#ABB2BF;">,</span><span style="color:#56B6C2;"> socklen_t</span><span style="color:#C678DD;"> *</span><span style="color:#E06C75;font-style:italic;">addrlen</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/1492928416812_4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>或者网友提供的</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-0.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="非阻塞式-i-o" tabindex="-1"><a class="header-anchor" href="#非阻塞式-i-o"><span><a href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-i-o">#</a> 非阻塞式 I/O</span></a></h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/1492929000361_5.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>或者网友提供的</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="i-o-复用" tabindex="-1"><a class="header-anchor" href="#i-o-复用"><span><a href="#i-o-%E5%A4%8D%E7%94%A8">#</a> I/O 复用</span></a></h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/1492929444818_6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>或者网友提供的</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="信号驱动-i-o" tabindex="-1"><a class="header-anchor" href="#信号驱动-i-o"><span><a href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-i-o">#</a> 信号驱动 I/O</span></a></h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/1492929553651_7.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>或者网友提供的</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="异步-i-o" tabindex="-1"><a class="header-anchor" href="#异步-i-o"><span><a href="#%E5%BC%82%E6%AD%A5-i-o">#</a> 异步 I/O</span></a></h3><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/1492930243286_8.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>或者网友提供的</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="i-o-模型比较" tabindex="-1"><a class="header-anchor" href="#i-o-模型比较"><span><a href="#i-o-%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83">#</a> I/O 模型比较</span></a></h2><h3 id="同步-i-o-与异步-i-o" tabindex="-1"><a class="header-anchor" href="#同步-i-o-与异步-i-o"><span><a href="#%E5%90%8C%E6%AD%A5-i-o-%E4%B8%8E%E5%BC%82%E6%AD%A5-i-o">#</a> 同步 I/O 与异步 I/O</span></a></h3><ul><li>同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。</li><li>异步 I/O: 不会阻塞。</li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h3 id="五大-i-o-模型比较" tabindex="-1"><a class="header-anchor" href="#五大-i-o-模型比较"><span><a href="#%E4%BA%94%E5%A4%A7-i-o-%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83">#</a> 五大 I/O 模型比较</span></a></h3><p>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/1492928105791_3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用"><span><a href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">#</a> IO多路复用</span></a></h2><blockquote><p>IO多路复用最为重要，后面的文章<a href="">Java NIO - IO多路复用详解</a>将对IO多路复用，Ractor模型以及Java NIO对其的支持作详解。</p></blockquote><p>这里主要概要性的理解: IO多路复用工作模式和应用。</p><h3 id="io多路复用工作模式" tabindex="-1"><a class="header-anchor" href="#io多路复用工作模式"><span><a href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">#</a> IO多路复用工作模式</span></a></h3><p>epoll 的描述符事件有两种触发模式: LT(level trigger)和 ET(edge trigger)。</p><h4 id="_1-lt-模式" tabindex="-1"><a class="header-anchor" href="#_1-lt-模式"><span><a href="#_1-lt-%E6%A8%A1%E5%BC%8F">#</a> 1. LT 模式</span></a></h4><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><h4 id="_2-et-模式" tabindex="-1"><a class="header-anchor" href="#_2-et-模式"><span><a href="#_2-et-%E6%A8%A1%E5%BC%8F">#</a> 2. ET 模式</span></a></h4><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 应用场景</span></a></h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><h4 id="_1-select-应用场景" tabindex="-1"><a class="header-anchor" href="#_1-select-应用场景"><span><a href="#_1-select-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 1. select 应用场景</span></a></h4><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p><h4 id="_2-poll-应用场景" tabindex="-1"><a class="header-anchor" href="#_2-poll-应用场景"><span><a href="#_2-poll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 2. poll 应用场景</span></a></h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。</p><h4 id="_3-epoll-应用场景" tabindex="-1"><a class="header-anchor" href="#_3-epoll-应用场景"><span><a href="#_3-epoll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 3. epoll 应用场景</span></a></h4><p>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a> 参考资料</span></a></h2>`,70),t=[o];function p(s,r){return a(),l("div",null,t)}const c=i(n,[["render",p],["__file","IO 模型 Unix IO 模型.html.vue"]]),h=JSON.parse(`{"path":"/posts/Java/IO-NIO-AIO/IO%20%E6%A8%A1%E5%9E%8B%20Unix%20IO%20%E6%A8%A1%E5%9E%8B.html","title":"IO 模型 Unix IO 模型","lang":"zh-CN","frontmatter":{"title":"IO 模型 Unix IO 模型","subtitle":"Java，Java开发，Java 体系","date":"2024-03-11T14:36:26.000Z","category":["Java"],"tag":["Java","IO"],"order":7,"description":"本文主要简要介绍 Unix I/O 5种模型，并对5大模型比较，并重点为后续章节解释IO多路复用做铺垫。 IO 模型 Unix IO 模型 Unix IO 模型简介 阻塞式 I/O 非阻塞式 I/O I/O 复用 信号驱动 I/O 异步 I/O I/O 模型比较 同步 I/O 与异步 I/O 五大 I/O 模型比较 IO多路复用 IO多路复用工作模式 ...","head":[["meta",{"property":"og:url","content":"https://cactusli.net/posts/Java/IO-NIO-AIO/IO%20%E6%A8%A1%E5%9E%8B%20Unix%20IO%20%E6%A8%A1%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Cactus's Blog"}],["meta",{"property":"og:title","content":"IO 模型 Unix IO 模型"}],["meta",{"property":"og:description","content":"本文主要简要介绍 Unix I/O 5种模型，并对5大模型比较，并重点为后续章节解释IO多路复用做铺垫。 IO 模型 Unix IO 模型 Unix IO 模型简介 阻塞式 I/O 非阻塞式 I/O I/O 复用 信号驱动 I/O 异步 I/O I/O 模型比较 同步 I/O 与异步 I/O 五大 I/O 模型比较 IO多路复用 IO多路复用工作模式 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://lixuanfengs.github.io/blog-images/vp/Java/1492928416812_4.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-17T09:29:14.000Z"}],["meta",{"property":"article:author","content":"Cactus li"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"IO"}],["meta",{"property":"article:published_time","content":"2024-03-11T14:36:26.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-17T09:29:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"IO 模型 Unix IO 模型\\",\\"image\\":[\\"https://lixuanfengs.github.io/blog-images/vp/Java/1492928416812_4.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-0.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/1492929000361_5.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-1.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/1492929444818_6.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-2.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/1492929553651_7.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-3.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/1492930243286_8.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/java-io-model-4.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/1492928105791_3.png\\"],\\"datePublished\\":\\"2024-03-11T14:36:26.000Z\\",\\"dateModified\\":\\"2024-03-17T09:29:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cactus li\\",\\"url\\":\\"https://cactusli.net\\"}]}"]]},"headers":[{"level":2,"title":"# Unix IO 模型简介","slug":"unix-io-模型简介","link":"#unix-io-模型简介","children":[{"level":3,"title":"# 阻塞式 I/O","slug":"阻塞式-i-o","link":"#阻塞式-i-o","children":[]},{"level":3,"title":"# 非阻塞式 I/O","slug":"非阻塞式-i-o","link":"#非阻塞式-i-o","children":[]},{"level":3,"title":"# I/O 复用","slug":"i-o-复用","link":"#i-o-复用","children":[]},{"level":3,"title":"# 信号驱动 I/O","slug":"信号驱动-i-o","link":"#信号驱动-i-o","children":[]},{"level":3,"title":"# 异步 I/O","slug":"异步-i-o","link":"#异步-i-o","children":[]}]},{"level":2,"title":"# I/O 模型比较","slug":"i-o-模型比较","link":"#i-o-模型比较","children":[{"level":3,"title":"# 同步 I/O 与异步 I/O","slug":"同步-i-o-与异步-i-o","link":"#同步-i-o-与异步-i-o","children":[]},{"level":3,"title":"# 五大 I/O 模型比较","slug":"五大-i-o-模型比较","link":"#五大-i-o-模型比较","children":[]}]},{"level":2,"title":"# IO多路复用","slug":"io多路复用","link":"#io多路复用","children":[{"level":3,"title":"# IO多路复用工作模式","slug":"io多路复用工作模式","link":"#io多路复用工作模式","children":[]},{"level":3,"title":"# 应用场景","slug":"应用场景","link":"#应用场景","children":[]}]},{"level":2,"title":"# 参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1710139794000,"updatedTime":1710667754000,"contributors":[{"name":"lixuanfengs","email":"1183895890@qq.com","commits":2}]},"readingTime":{"minutes":6.82,"words":2046},"filePathRelative":"posts/Java/IO-NIO-AIO/IO 模型 Unix IO 模型.md","localizedDate":"2024年3月11日","excerpt":"<blockquote>\\n<p>本文主要简要介绍 Unix I/O 5种模型，并对5大模型比较，并重点为后续章节解释IO多路复用做铺垫。</p>\\n</blockquote>\\n<ul>\\n<li>IO 模型 Unix IO 模型\\n<ul>\\n<li>Unix IO 模型简介\\n<ul>\\n<li><a href=\\"#%E9%98%BB%E5%A1%9E%E5%BC%8F-io\\">阻塞式 I/O</a></li>\\n<li><a href=\\"#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-io\\">非阻塞式 I/O</a></li>\\n<li><a href=\\"#io-%E5%A4%8D%E7%94%A8\\">I/O 复用</a></li>\\n<li><a href=\\"#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-io\\">信号驱动 I/O</a></li>\\n<li><a href=\\"#%E5%BC%82%E6%AD%A5-io\\">异步 I/O</a></li>\\n</ul>\\n</li>\\n<li>I/O 模型比较\\n<ul>\\n<li><a href=\\"#%E5%90%8C%E6%AD%A5-io-%E4%B8%8E%E5%BC%82%E6%AD%A5-io\\">同步 I/O 与异步 I/O</a></li>\\n<li><a href=\\"#%E4%BA%94%E5%A4%A7-io-%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83\\">五大 I/O 模型比较</a></li>\\n</ul>\\n</li>\\n<li>IO多路复用\\n<ul>\\n<li>IO多路复用工作模式\\n<ul>\\n<li><a href=\\"#1-lt-%E6%A8%A1%E5%BC%8F\\">1. LT 模式</a></li>\\n<li><a href=\\"#2-et-%E6%A8%A1%E5%BC%8F\\">2. ET 模式</a></li>\\n</ul>\\n</li>\\n<li>应用场景\\n<ul>\\n<li><a href=\\"#1-select-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\\">1. select 应用场景</a></li>\\n<li><a href=\\"#2-poll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\\">2. poll 应用场景</a></li>\\n<li><a href=\\"#3-epoll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\\">3. epoll 应用场景</a></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><a href=\\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\\">参考资料</a></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{c as comp,h as data};
