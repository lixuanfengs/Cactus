import{_ as e,o as s,c as a,h as l}from"./app-Ntmq5oN3.js";const n={},t=l(`<blockquote><p>本文主要对Stack &amp; Queue进行源码解析。</p></blockquote><ul><li>Stack &amp; Queue 源码解析 <ul><li><a href="#stack--queue%E6%A6%82%E8%BF%B0">Stack &amp; Queue概述</a></li><li><a href="#queue">Queue</a></li><li><a href="#deque">Deque</a></li><li>方法剖析 <ul><li><a href="#addfirst">addFirst()</a></li><li><a href="#addlast">addLast()</a></li><li><a href="#pollfirst">pollFirst()</a></li><li><a href="#polllast">pollLast()</a></li><li><a href="#peekfirst">peekFirst()</a></li><li><a href="#peeklast">peekLast()</a></li></ul></li></ul></li></ul><h2 id="stack-queue概述" tabindex="-1"><a class="header-anchor" href="#stack-queue概述"><span><a href="#stack-queue%E6%A6%82%E8%BF%B0">#</a> Stack &amp; Queue概述</span></a></h2><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了(次选是<em>LinkedList</em>)。</p><h2 id="queue" tabindex="-1"><a class="header-anchor" href="#queue"><span><a href="#queue">#</a> Queue</span></a></h2><p><em>Queue</em>接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的<em>insertion</em>, <em>extraction</em>和<em>inspection</em>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h2 id="deque" tabindex="-1"><a class="header-anchor" href="#deque"><span><a href="#deque">#</a> Deque</span></a></h2><p><code>Deque</code>是&quot;double ended queue&quot;, 表示双向的队列，英文读作&quot;deck&quot;. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table><thead><tr><th></th><th>First Element - Head</th><th></th><th>Last Element - Tail</th><th></th></tr></thead><tbody><tr><td></td><td>Throws exception</td><td>Special value</td><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>Examine</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>当把<code>Deque</code>当做FIFO的<code>queue</code>来使用时，元素是从<code>deque</code>的尾部添加，从头部进行删除的； 所以<code>deque</code>的部分方法是和<code>queue</code>是等同的。具体如下:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口:</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>getFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然*Deque*的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，加之上一篇已经讲解过<em>LinkedList</em>，本文将着重讲解<em>ArrayDeque</em>的具体实现。</p><p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组(circular array)</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_base.png" alt="ArrayDeque_base.png" tabindex="0" loading="lazy"><figcaption>ArrayDeque_base.png</figcaption></figure><p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h2 id="方法剖析" tabindex="-1"><a class="header-anchor" href="#方法剖析"><span><a href="#%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90">#</a> 方法剖析</span></a></h2><h3 id="addfirst" tabindex="-1"><a class="header-anchor" href="#addfirst"><span><a href="#addfirst">#</a> addFirst()</span></a></h3><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_addFirst.png" alt="ArrayDeque_addFirst.png" tabindex="0" loading="lazy"><figcaption>ArrayDeque_addFirst.png</figcaption></figure><p>实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">//addFirst(E e)</span></span>
<span class="line"><span style="color:#C678DD;">public</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> addFirst</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">E</span><span style="color:#E06C75;"> e) {</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (e </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#7F848E;font-style:italic;">//不允许放入null</span></span>
<span class="line"><span style="color:#C678DD;">        throw</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> NullPointerException</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    elements[head </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (head </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">elements</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//2.下标是否越界</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (head </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> tail)</span><span style="color:#7F848E;font-style:italic;">//1.空间是否够用</span></span>
<span class="line"><span style="color:#61AFEF;">        doubleCapacity</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//扩容</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数(其实只可能是-1)，则相当于对其取相对于<code>elements.length</code>的补码。</p><p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_doubleCapacity.png" alt="ArrayDeque_doubleCapacity.png" tabindex="0" loading="lazy"><figcaption>ArrayDeque_doubleCapacity.png</figcaption></figure><p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">//doubleCapacity()</span></span>
<span class="line"><span style="color:#C678DD;">private</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> doubleCapacity</span><span style="color:#E06C75;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    assert</span><span style="color:#E06C75;"> head </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> tail</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> head</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> elements</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> r </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // head右边元素的个数</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> newCapacity </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//原空间的2倍</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (newCapacity </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#C678DD;">        throw</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> IllegalStateException</span><span style="color:#E06C75;">(</span><span style="color:#98C379;">&quot;Sorry, deque too big&quot;</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    Object</span><span style="color:#E06C75;">[] a </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> Object</span><span style="color:#E06C75;">[newCapacity]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    System</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">arraycopy</span><span style="color:#ABB2BF;">(elements, p, a, </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">, r);</span><span style="color:#7F848E;font-style:italic;">//复制右半部分，对应上图中绿色部分</span></span>
<span class="line"><span style="color:#E5C07B;">    System</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">arraycopy</span><span style="color:#ABB2BF;">(elements, </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">, a, r, p);</span><span style="color:#7F848E;font-style:italic;">//复制左半部分，对应上图中灰色部分</span></span>
<span class="line"><span style="color:#E06C75;">    elements </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">E</span><span style="color:#E06C75;">[])a</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    head </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    tail </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="addlast" tabindex="-1"><a class="header-anchor" href="#addlast"><span><a href="#addlast">#</a> addLast()</span></a></h3><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_addLast.png" alt="ArrayDeque_addLast.png" tabindex="0" loading="lazy"><figcaption>ArrayDeque_addLast.png</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> addLast</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">E</span><span style="color:#E06C75;"> e) {</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (e </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#7F848E;font-style:italic;">//不允许放入null</span></span>
<span class="line"><span style="color:#C678DD;">        throw</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> NullPointerException</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    elements[tail] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//赋值</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> ( (tail </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (tail </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">elements</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> head)</span><span style="color:#7F848E;font-style:italic;">//下标越界处理</span></span>
<span class="line"><span style="color:#61AFEF;">        doubleCapacity</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//扩容</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h3 id="pollfirst" tabindex="-1"><a class="header-anchor" href="#pollfirst"><span><a href="#pollfirst">#</a> pollFirst()</span></a></h3><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> E</span><span style="color:#61AFEF;"> pollFirst</span><span style="color:#E06C75;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> head</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    E</span><span style="color:#E06C75;"> result </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> elements[head]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (result </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#7F848E;font-style:italic;">//null值意味着deque为空</span></span>
<span class="line"><span style="color:#C678DD;">        return</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    elements[h] </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//let GC work</span></span>
<span class="line"><span style="color:#E06C75;">    head </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (head </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">elements</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//下标越界处理</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> result</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="polllast" tabindex="-1"><a class="header-anchor" href="#polllast"><span><a href="#polllast">#</a> pollLast()</span></a></h3><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> E</span><span style="color:#61AFEF;"> pollLast</span><span style="color:#E06C75;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> t </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (tail </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">elements</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//tail的上一个位置是最后一个元素</span></span>
<span class="line"><span style="color:#E5C07B;">    E</span><span style="color:#E06C75;"> result </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> elements[t]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (result </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#7F848E;font-style:italic;">//null值意味着deque为空</span></span>
<span class="line"><span style="color:#C678DD;">        return</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    elements[t] </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//let GC work</span></span>
<span class="line"><span style="color:#E06C75;">    tail </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> t</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> result</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="peekfirst" tabindex="-1"><a class="header-anchor" href="#peekfirst"><span><a href="#peekfirst">#</a> peekFirst()</span></a></h3><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> E</span><span style="color:#61AFEF;"> peekFirst</span><span style="color:#E06C75;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> elements[head]</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // elements[head] is null if deque empty</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="peeklast" tabindex="-1"><a class="header-anchor" href="#peeklast"><span><a href="#peeklast">#</a> peekLast()</span></a></h3><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> E</span><span style="color:#61AFEF;"> peekLast</span><span style="color:#E06C75;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> elements[(tail </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">elements</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>`,51),o=[t];function p(c,r){return s(),a("div",null,o)}const i=e(n,[["render",p],["__file","Stack _ Queue 源码解析.html.vue"]]),u=JSON.parse(`{"path":"/posts/Java/Collection/Stack%20_%20Queue%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html","title":"Stack & Queue 源码解析","lang":"zh-CN","frontmatter":{"title":"Stack & Queue 源码解析","subtitle":"Java，Java开发，Java 体系","date":"2024-03-06T10:15:26.000Z","category":["Java"],"tag":["Java","Collection"],"order":4,"description":"本文主要对Stack & Queue进行源码解析。 Stack & Queue 源码解析 Stack & Queue概述 Queue Deque 方法剖析 addFirst() addLast() pollFirst() pollLast() peekFirst() peekLast() # Stack & Queue概述 Java里有一个叫做Stac...","head":[["meta",{"property":"og:url","content":"https://cactusli.net/posts/Java/Collection/Stack%20_%20Queue%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"Cactus's Blog"}],["meta",{"property":"og:title","content":"Stack & Queue 源码解析"}],["meta",{"property":"og:description","content":"本文主要对Stack & Queue进行源码解析。 Stack & Queue 源码解析 Stack & Queue概述 Queue Deque 方法剖析 addFirst() addLast() pollFirst() pollLast() peekFirst() peekLast() # Stack & Queue概述 Java里有一个叫做Stac..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_base.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-08T03:51:56.000Z"}],["meta",{"property":"article:author","content":"Cactus li"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Collection"}],["meta",{"property":"article:published_time","content":"2024-03-06T10:15:26.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-08T03:51:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Stack & Queue 源码解析\\",\\"image\\":[\\"https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_base.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_addFirst.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_doubleCapacity.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/ArrayDeque_addLast.png\\"],\\"datePublished\\":\\"2024-03-06T10:15:26.000Z\\",\\"dateModified\\":\\"2024-03-08T03:51:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cactus li\\",\\"url\\":\\"https://cactusli.net\\"}]}"]]},"headers":[{"level":2,"title":"# Stack & Queue概述","slug":"stack-queue概述","link":"#stack-queue概述","children":[]},{"level":2,"title":"# Queue","slug":"queue","link":"#queue","children":[]},{"level":2,"title":"# Deque","slug":"deque","link":"#deque","children":[]},{"level":2,"title":"# 方法剖析","slug":"方法剖析","link":"#方法剖析","children":[{"level":3,"title":"# addFirst()","slug":"addfirst","link":"#addfirst","children":[]},{"level":3,"title":"# addLast()","slug":"addlast","link":"#addlast","children":[]},{"level":3,"title":"# pollFirst()","slug":"pollfirst","link":"#pollfirst","children":[]},{"level":3,"title":"# pollLast()","slug":"polllast","link":"#polllast","children":[]},{"level":3,"title":"# peekFirst()","slug":"peekfirst","link":"#peekfirst","children":[]},{"level":3,"title":"# peekLast()","slug":"peeklast","link":"#peeklast","children":[]}]}],"git":{"createdTime":1709869916000,"updatedTime":1709869916000,"contributors":[{"name":"lixuanfengs","email":"1183895890@qq.com","commits":1}]},"readingTime":{"minutes":7.18,"words":2154},"filePathRelative":"posts/Java/Collection/Stack & Queue 源码解析.md","localizedDate":"2024年3月6日","excerpt":"<blockquote>\\n<p>本文主要对Stack &amp; Queue进行源码解析。</p>\\n</blockquote>\\n<ul>\\n<li>Stack &amp; Queue 源码解析\\n<ul>\\n<li><a href=\\"#stack--queue%E6%A6%82%E8%BF%B0\\">Stack &amp; Queue概述</a></li>\\n<li><a href=\\"#queue\\">Queue</a></li>\\n<li><a href=\\"#deque\\">Deque</a></li>\\n<li>方法剖析\\n<ul>\\n<li><a href=\\"#addfirst\\">addFirst()</a></li>\\n<li><a href=\\"#addlast\\">addLast()</a></li>\\n<li><a href=\\"#pollfirst\\">pollFirst()</a></li>\\n<li><a href=\\"#polllast\\">pollLast()</a></li>\\n<li><a href=\\"#peekfirst\\">peekFirst()</a></li>\\n<li><a href=\\"#peeklast\\">peekLast()</a></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{i as comp,u as data};
