import{_ as n,c as a,f as l,o as p}from"./app-CIOQhzI3.js";const o={};function e(t,s){return p(),a("div",null,s[0]||(s[0]=[l(`<blockquote><p>DK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap；本文将分别介绍这两种方式的实现方案及其区别。</p></blockquote><ul><li>JUC 集合之 ConcurrentHashMap 详解 <ul><li><a href="#%E5%B8%A6%E7%9D%80bat%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8E%BB%E7%90%86%E8%A7%A3">带着BAT大厂的面试问题去理解</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88hashtable%E6%85%A2">为什么HashTable慢</a></li><li>ConcurrentHashMap - JDK 1.7 <ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li><li><a href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">put 过程分析</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A7%BD-ensuresegment">初始化槽: ensureSegment</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%86%99%E5%85%A5%E9%94%81-scanandlockforput">获取写入锁: scanAndLockForPut</a></li><li><a href="#%E6%89%A9%E5%AE%B9-rehash">扩容: rehash</a></li><li><a href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">get 过程分析</a></li><li><a href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">并发问题分析</a></li></ul></li><li>ConcurrentHashMap - JDK 1.8 <ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1">数据结构</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1">初始化</a></li><li><a href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1">put 过程分析</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84-inittable">初始化数组: initTable</a></li><li><a href="#%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91-treeifybin">链表转红黑树: treeifyBin</a></li><li><a href="#%E6%89%A9%E5%AE%B9-trypresize">扩容: tryPresize</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB-transfer">数据迁移: transfer</a></li><li><a href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1">get 过程分析</a></li></ul></li><li><a href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93">对比总结</a></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">参考文章</a></li></ul></li></ul><h2 id="带着bat大厂的面试问题去理解" tabindex="-1"><a class="header-anchor" href="#带着bat大厂的面试问题去理解"><span><a href="#%E5%B8%A6%E7%9D%80bat%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8E%BB%E7%90%86%E8%A7%A3">#</a> 带着BAT大厂的面试问题去理解</span></a></h2><p>提示</p><p>请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。@pdai</p><ul><li>为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么?</li><li>ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题</li><li>ConcurrentHashMap JDK1.7实现的原理是什么? 分段锁机制</li><li>ConcurrentHashMap JDK1.8实现的原理是什么? 数组+链表+红黑树，CAS</li><li>ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?</li><li>ConcurrentHashMap JDK1.7说说其put的机制?</li><li>ConcurrentHashMap JDK1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容)</li><li>ConcurrentHashMap JDK1.8是如何扩容的? tryPresize</li><li>ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?</li><li>ConcurrentHashMap JDK1.8是如何进行数据迁移的? transfer</li></ul><h2 id="为什么hashtable慢" tabindex="-1"><a class="header-anchor" href="#为什么hashtable慢"><span><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88hashtable%E6%85%A2">#</a> 为什么HashTable慢</span></a></h2><p>Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。</p><h2 id="concurrenthashmap-jdk-1-7" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-jdk-1-7"><span><a href="#concurrenthashmap-jdk-1-7">#</a> ConcurrentHashMap - JDK 1.7</span></a></h2><p>在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap.</p><p>简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。接下来分析JDK1.7版本中ConcurrentHashMap的实现原理。</p><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a> 数据结构</span></a></h3><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/java-thread-x-concurrent-hashmap-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>concurrencyLevel</code>: 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">#</a> 初始化</span></a></h3><ul><li>initialCapacity: 初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</li><li>loadFactor: 负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> ConcurrentHashMap</span><span style="color:#E06C75;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> initialCapacity</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#C678DD;">                         float</span><span style="color:#E06C75;"> loadFactor</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> concurrencyLevel) {</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">(loadFactor </span><span style="color:#56B6C2;">&gt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> initialCapacity </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#56B6C2;"> ||</span><span style="color:#E06C75;"> concurrencyLevel </span><span style="color:#56B6C2;">&lt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#C678DD;">        throw</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> IllegalArgumentException</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (concurrencyLevel </span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> MAX_SEGMENTS)</span></span>
<span class="line"><span style="color:#E06C75;">        concurrencyLevel </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> MAX_SEGMENTS</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // Find power-of-two sizes best matching arguments</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> sshift </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> ssize </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#E06C75;"> (ssize </span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;"> concurrencyLevel) {</span></span>
<span class="line"><span style="color:#ABB2BF;">        ++</span><span style="color:#E06C75;">sshift</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        ssize </span><span style="color:#56B6C2;">&lt;&lt;=</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span></span>
<span class="line"><span style="color:#E5C07B;">    this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">segmentShift</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 32</span><span style="color:#56B6C2;"> -</span><span style="color:#E06C75;"> sshift</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">segmentMask</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> ssize </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (initialCapacity </span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> MAXIMUM_CAPACITY)</span></span>
<span class="line"><span style="color:#E06C75;">        initialCapacity </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> MAXIMUM_CAPACITY</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // initialCapacity 是设置整个 map 初始的大小，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> c </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> initialCapacity </span><span style="color:#56B6C2;">/</span><span style="color:#E06C75;"> ssize</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (c </span><span style="color:#56B6C2;">*</span><span style="color:#E06C75;"> ssize </span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;"> initialCapacity)</span></span>
<span class="line"><span style="color:#ABB2BF;">        ++</span><span style="color:#E06C75;">c</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> cap </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> MIN_SEGMENT_TABLE_CAPACITY</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> </span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#E06C75;"> (cap </span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;"> c)</span></span>
<span class="line"><span style="color:#E06C75;">        cap </span><span style="color:#56B6C2;">&lt;&lt;=</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 创建 Segment 数组，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 并创建数组的第一个元素 segment[0]</span></span>
<span class="line"><span style="color:#E5C07B;">    Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> s0 </span><span style="color:#56B6C2;">=</span></span>
<span class="line"><span style="color:#C678DD;">        new</span><span style="color:#E5C07B;"> Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(loadFactor</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> (</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;">)(cap </span><span style="color:#56B6C2;">*</span><span style="color:#E06C75;"> loadFactor)</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">                         (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[])</span><span style="color:#C678DD;">new</span><span style="color:#E5C07B;"> HashEntry</span><span style="color:#E06C75;">[cap])</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] ss </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Segment</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[])</span><span style="color:#C678DD;">new</span><span style="color:#E5C07B;"> Segment</span><span style="color:#E06C75;">[ssize]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 往数组写入 segment[0]</span></span>
<span class="line"><span style="color:#E5C07B;">    UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">putOrderedObject</span><span style="color:#ABB2BF;">(ss, SBASE, s0);</span><span style="color:#7F848E;font-style:italic;"> // ordered write of segments[0]</span></span>
<span class="line"><span style="color:#E5C07B;">    this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">segments</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> ss</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化完成，我们得到了一个 Segment 数组。</p><p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后:</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到</li></ul><h3 id="put-过程分析" tabindex="-1"><a class="header-anchor" href="#put-过程分析"><span><a href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">#</a> put 过程分析</span></a></h3><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> V</span><span style="color:#61AFEF;"> put</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">K</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#E06C75;"> value) {</span></span>
<span class="line"><span style="color:#E5C07B;">    Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> s</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (value </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#C678DD;">        throw</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> NullPointerException</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 1. 计算 key 的 hash 值</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> hash </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> hash</span><span style="color:#E06C75;">(key)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 2. 根据 hash 值找到 Segment 数组中的位置 j</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> j </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (hash </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#E06C75;"> segmentShift) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> segmentMask</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // ensureSegment(j) 对 segment[j] 进行初始化</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> ((s </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Segment</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">)</span><span style="color:#E5C07B;">UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">getObject</span><span style="color:#7F848E;font-style:italic;">          // nonvolatile; recheck</span></span>
<span class="line"><span style="color:#E06C75;">         (segments</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> (j </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#E06C75;"> SSHIFT) </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> SBASE)) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) </span><span style="color:#7F848E;font-style:italic;">//  in ensureSegment</span></span>
<span class="line"><span style="color:#E06C75;">        s </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> ensureSegment</span><span style="color:#E06C75;">(j)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 3. 插入新值到 槽 s 中</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E5C07B;"> s</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">put</span><span style="color:#ABB2BF;">(key, hash, value, </span><span style="color:#D19A66;">false</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 <code>数组+链表</code> 组成的。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">final</span><span style="color:#E5C07B;"> V</span><span style="color:#61AFEF;"> put</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">K</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> boolean</span><span style="color:#E06C75;"> onlyIfAbsent) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 在往该 segment 写入前，需要先获取该 segment 的独占锁</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //    先看主流程，后面还会具体介绍这部分内容</span></span>
<span class="line"><span style="color:#E5C07B;">    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> node </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> tryLock</span><span style="color:#E06C75;">() </span><span style="color:#C678DD;">?</span><span style="color:#D19A66;"> null</span><span style="color:#C678DD;"> :</span></span>
<span class="line"><span style="color:#61AFEF;">        scanAndLockForPut</span><span style="color:#E06C75;">(key</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> value)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    V</span><span style="color:#E06C75;"> oldValue</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    try</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 这个是 segment 内部的数组</span></span>
<span class="line"><span style="color:#E5C07B;">        HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 再利用 hash 值，求应该放置的数组下标</span></span>
<span class="line"><span style="color:#C678DD;">        int</span><span style="color:#E06C75;"> index </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> hash</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // first 是数组该位置处的链表的表头</span></span>
<span class="line"><span style="color:#E5C07B;">        HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> first </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> entryAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> index)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span></span>
<span class="line"><span style="color:#C678DD;">        for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> first</span><span style="color:#ABB2BF;">;;</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (e </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">                K</span><span style="color:#E06C75;"> k</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> ((k </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> key </span><span style="color:#56B6C2;">||</span></span>
<span class="line"><span style="color:#E06C75;">                    (</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> ==</span><span style="color:#E06C75;"> hash </span><span style="color:#56B6C2;">&amp;&amp;</span><span style="color:#E5C07B;"> key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">equals</span><span style="color:#ABB2BF;">(k)</span><span style="color:#E06C75;">)) {</span></span>
<span class="line"><span style="color:#E06C75;">                    oldValue </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">value</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                    if</span><span style="color:#E06C75;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">onlyIfAbsent) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 覆盖旧值</span></span>
<span class="line"><span style="color:#E5C07B;">                        e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">value</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">                        ++</span><span style="color:#E06C75;">modCount</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#C678DD;">                    break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 继续顺着链表走</span></span>
<span class="line"><span style="color:#E06C75;">                e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#C678DD;">            else</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (node </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E5C07B;">                    node</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">setNext</span><span style="color:#ABB2BF;">(first);</span></span>
<span class="line"><span style="color:#C678DD;">                else</span></span>
<span class="line"><span style="color:#E06C75;">                    node </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> first)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">                int</span><span style="color:#E06C75;"> c </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> count </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (c </span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> threshold </span><span style="color:#56B6C2;">&amp;&amp;</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> &lt;</span><span style="color:#E06C75;"> MAXIMUM_CAPACITY)</span></span>
<span class="line"><span style="color:#61AFEF;">                    rehash</span><span style="color:#E06C75;">(node)</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // 扩容后面也会具体分析</span></span>
<span class="line"><span style="color:#C678DD;">                else</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 其实就是将新的节点设置成原链表的表头</span></span>
<span class="line"><span style="color:#61AFEF;">                    setEntryAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> index</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> node)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">                ++</span><span style="color:#E06C75;">modCount</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                count </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> c</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                oldValue </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    } </span><span style="color:#C678DD;">finally</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 解锁</span></span>
<span class="line"><span style="color:#61AFEF;">        unlock</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> oldValue</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><h3 id="初始化槽-ensuresegment" tabindex="-1"><a class="header-anchor" href="#初始化槽-ensuresegment"><span><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A7%BD-ensuresegment">#</a> 初始化槽: ensureSegment</span></a></h3><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">private</span><span style="color:#E5C07B;"> Segment</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#61AFEF;"> ensureSegment</span><span style="color:#E06C75;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> k) {</span></span>
<span class="line"><span style="color:#C678DD;">    final</span><span style="color:#E5C07B;"> Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] ss </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">segments</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    long</span><span style="color:#E06C75;"> u </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (k </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#E06C75;"> SSHIFT) </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> SBASE</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // raw offset</span></span>
<span class="line"><span style="color:#E5C07B;">    Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> seg</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> ((seg </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Segment</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">)</span><span style="color:#E5C07B;">UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getObjectVolatile</span><span style="color:#ABB2BF;">(ss, u)</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 这里看到为什么之前要初始化 segment[0] 了，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span></span>
<span class="line"><span style="color:#E5C07B;">        Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> proto </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> ss[</span><span style="color:#D19A66;">0</span><span style="color:#E06C75;">]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">        int</span><span style="color:#E06C75;"> cap </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> proto</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">table</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">        float</span><span style="color:#E06C75;"> lf </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> proto</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">loadFactor</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">        int</span><span style="color:#E06C75;"> threshold </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;">)(cap </span><span style="color:#56B6C2;">*</span><span style="color:#E06C75;"> lf)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 初始化 segment[k] 内部的数组</span></span>
<span class="line"><span style="color:#E5C07B;">        HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[])</span><span style="color:#C678DD;">new</span><span style="color:#E5C07B;"> HashEntry</span><span style="color:#E06C75;">[cap]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> ((seg </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Segment</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">)</span><span style="color:#E5C07B;">UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getObjectVolatile</span><span style="color:#ABB2BF;">(ss, u)</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#56B6C2;">            ==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) { </span><span style="color:#7F848E;font-style:italic;">// 再次检查一遍该槽是否被其他线程初始化了。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">            Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> s </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(lf</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> threshold</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> tab)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span></span>
<span class="line"><span style="color:#C678DD;">            while</span><span style="color:#E06C75;"> ((seg </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Segment</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">)</span><span style="color:#E5C07B;">UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getObjectVolatile</span><span style="color:#ABB2BF;">(ss, u)</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#56B6C2;">                   ==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">compareAndSwapObject</span><span style="color:#ABB2BF;">(ss, u, </span><span style="color:#D19A66;">null</span><span style="color:#ABB2BF;">, seg </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> s)</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#C678DD;">                    break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> seg</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p><h3 id="获取写入锁-scanandlockforput" tabindex="-1"><a class="header-anchor" href="#获取写入锁-scanandlockforput"><span><a href="#%E8%8E%B7%E5%8F%96%E5%86%99%E5%85%A5%E9%94%81-scanandlockforput">#</a> 获取写入锁: scanAndLockForPut</span></a></h3><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">private</span><span style="color:#E5C07B;"> HashEntry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#61AFEF;"> scanAndLockForPut</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">K</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#E06C75;"> value) {</span></span>
<span class="line"><span style="color:#E5C07B;">    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> first </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> entryForHash</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hash)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> first</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> node </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> retries </span><span style="color:#56B6C2;">=</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // negative while locating node</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 循环获取锁</span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#E06C75;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#61AFEF;">tryLock</span><span style="color:#E06C75;">()) {</span></span>
<span class="line"><span style="color:#E5C07B;">        HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> f</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // to recheck first below</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> (retries </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (e </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (node </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) </span><span style="color:#7F848E;font-style:italic;">// speculatively create node</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 进到这里说明数组该位置的链表是空的，没有任何元素</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span></span>
<span class="line"><span style="color:#E06C75;">                    node </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                retries </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#C678DD;">            else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">equals</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E06C75;">                retries </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            else</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 顺着链表往下走</span></span>
<span class="line"><span style="color:#E06C75;">                e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        //    lock() 是阻塞方法，直到获取锁后返回</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (</span><span style="color:#ABB2BF;">++</span><span style="color:#E06C75;">retries </span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> MAX_SCAN_RETRIES) {</span></span>
<span class="line"><span style="color:#61AFEF;">            lock</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> ((retries </span><span style="color:#56B6C2;">&amp;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> 0</span><span style="color:#56B6C2;"> &amp;&amp;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span></span>
<span class="line"><span style="color:#E06C75;">                 (f </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> entryForHash</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hash)) </span><span style="color:#56B6C2;">!=</span><span style="color:#E06C75;"> first) {</span></span>
<span class="line"><span style="color:#E06C75;">            e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> first </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> f</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // re-traverse if entry changed</span></span>
<span class="line"><span style="color:#E06C75;">            retries </span><span style="color:#56B6C2;">=</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> node</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。</p><h3 id="扩容-rehash" tabindex="-1"><a class="header-anchor" href="#扩容-rehash"><span><a href="#%E6%89%A9%E5%AE%B9-rehash">#</a> 扩容: rehash</span></a></h3><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容，扩容后，容量为原来的 2 倍。</p><p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span>
<span class="line"><span style="color:#C678DD;">private</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> rehash</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> node) {</span></span>
<span class="line"><span style="color:#E5C07B;">    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] oldTable </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> oldCapacity </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> oldTable</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 2 倍</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> newCapacity </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> oldCapacity </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    threshold </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;">)(newCapacity </span><span style="color:#56B6C2;">*</span><span style="color:#E06C75;"> loadFactor)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 创建新数组</span></span>
<span class="line"><span style="color:#E5C07B;">    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] newTable </span><span style="color:#56B6C2;">=</span></span>
<span class="line"><span style="color:#E06C75;">        (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[]) </span><span style="color:#C678DD;">new</span><span style="color:#E5C07B;"> HashEntry</span><span style="color:#E06C75;">[newCapacity]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> sizeMask </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> newCapacity </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#E06C75;"> (</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;"> oldCapacity </span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">++</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // e 是链表的第一个元素</span></span>
<span class="line"><span style="color:#E5C07B;">        HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> oldTable[i]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> (e </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">            HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> next </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 计算应该放置在新数组中的位置，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span>
<span class="line"><span style="color:#C678DD;">            int</span><span style="color:#E06C75;"> idx </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> &amp;</span><span style="color:#E06C75;"> sizeMask</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (next </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)   </span><span style="color:#7F848E;font-style:italic;">// 该位置处只有一个元素，那比较好办</span></span>
<span class="line"><span style="color:#E06C75;">                newTable[idx] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            else</span><span style="color:#E06C75;"> { </span><span style="color:#7F848E;font-style:italic;">// Reuse consecutive sequence at same slot</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // e 是链表表头</span></span>
<span class="line"><span style="color:#E5C07B;">                HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> lastRun </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // idx 是当前链表的头节点 e 的新位置</span></span>
<span class="line"><span style="color:#C678DD;">                int</span><span style="color:#E06C75;"> lastIdx </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> idx</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span>
<span class="line"><span style="color:#C678DD;">                for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> last </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                     last </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                     last </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> last</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                    int</span><span style="color:#E06C75;"> k </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> last</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> &amp;</span><span style="color:#E06C75;"> sizeMask</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                    if</span><span style="color:#E06C75;"> (k </span><span style="color:#56B6C2;">!=</span><span style="color:#E06C75;"> lastIdx) {</span></span>
<span class="line"><span style="color:#E06C75;">                        lastIdx </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> k</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        lastRun </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> last</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span>
<span class="line"><span style="color:#E06C75;">                newTable[lastIdx] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> lastRun</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 下面的操作是处理 lastRun 之前的节点，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span>
<span class="line"><span style="color:#C678DD;">                for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">!=</span><span style="color:#E06C75;"> lastRun</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">                    V</span><span style="color:#E06C75;"> v </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">value</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                    int</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                    int</span><span style="color:#E06C75;"> k </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> sizeMask</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">                    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> newTable[k]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                    newTable[k] </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(h</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> v</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> n)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> nodeIndex </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> node</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> &amp;</span><span style="color:#E06C75;"> sizeMask</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // add the new node</span></span>
<span class="line"><span style="color:#E5C07B;">    node</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">setNext</span><span style="color:#ABB2BF;">(newTable[nodeIndex]);</span></span>
<span class="line"><span style="color:#E06C75;">    newTable[nodeIndex] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> node</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    table </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> newTable</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢?</p><p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。</p><h3 id="get-过程分析" tabindex="-1"><a class="header-anchor" href="#get-过程分析"><span><a href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">#</a> get 过程分析</span></a></h3><p>相对于 put 来说，get 就很简单了。</p><ul><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> V</span><span style="color:#61AFEF;"> get</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">Object</span><span style="color:#E06C75;"> key) {</span></span>
<span class="line"><span style="color:#E5C07B;">    Segment</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> s</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // manually integrate access methods to reduce overhead</span></span>
<span class="line"><span style="color:#E5C07B;">    HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] tab</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 1. hash 值</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> hash</span><span style="color:#E06C75;">(key)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    long</span><span style="color:#E06C75;"> u </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (((h </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#E06C75;"> segmentShift) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> segmentMask) </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#E06C75;"> SSHIFT) </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> SBASE</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 2. 根据 hash 找到对应的 segment</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> ((s </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Segment</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">)</span><span style="color:#E5C07B;">UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getObjectVolatile</span><span style="color:#ABB2BF;">(segments, u)</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> &amp;&amp;</span></span>
<span class="line"><span style="color:#E06C75;">        (tab </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> s</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">table</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 3. 找到segment 内部数组相应位置的链表，遍历</span></span>
<span class="line"><span style="color:#C678DD;">        for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">HashEntry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">) </span><span style="color:#E5C07B;">UNSAFE</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">getObjectVolatile</span></span>
<span class="line"><span style="color:#E06C75;">                 (tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> ((</span><span style="color:#C678DD;">long</span><span style="color:#E06C75;">)(((</span><span style="color:#E5C07B;">tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> h)) </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#E06C75;"> TSHIFT) </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> TBASE)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">             e </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">            K</span><span style="color:#E06C75;"> k</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> ((k </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> key </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> ==</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">&amp;&amp;</span><span style="color:#E5C07B;"> key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">equals</span><span style="color:#ABB2BF;">(k)</span><span style="color:#E06C75;">))</span></span>
<span class="line"><span style="color:#C678DD;">                return</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">value</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="并发问题分析" tabindex="-1"><a class="header-anchor" href="#并发问题分析"><span><a href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">#</a> 并发问题分析</span></a></h3><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ul><li>put 操作的线程安全性。 <ul><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ul></li><li>remove 操作的线程安全性。 <ul><li>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</li><li>get 操作需要遍历链表，但是 remove 操作会&quot;破坏&quot;链表。</li><li>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</li><li>如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头节点，那么需要将头节点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头节点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</li></ul></li></ul><h2 id="concurrenthashmap-jdk-1-8" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-jdk-1-8"><span><a href="#concurrenthashmap-jdk-1-8">#</a> ConcurrentHashMap - JDK 1.8</span></a></h2><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。</p><h3 id="数据结构-1" tabindex="-1"><a class="header-anchor" href="#数据结构-1"><span><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1">#</a> 数据结构</span></a></h3><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/java-thread-x-concurrent-hashmap-2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p><h3 id="初始化-1" tabindex="-1"><a class="header-anchor" href="#初始化-1"><span><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1">#</a> 初始化</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 这构造函数里，什么都不干</span></span>
<span class="line"><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> ConcurrentHashMap</span><span style="color:#E06C75;">() {</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> ConcurrentHashMap</span><span style="color:#E06C75;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> initialCapacity) {</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (initialCapacity </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#C678DD;">        throw</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> IllegalArgumentException</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> cap </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> ((initialCapacity </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> (MAXIMUM_CAPACITY </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)) </span><span style="color:#C678DD;">?</span></span>
<span class="line"><span style="color:#E06C75;">               MAXIMUM_CAPACITY </span><span style="color:#C678DD;">:</span></span>
<span class="line"><span style="color:#61AFEF;">               tableSizeFor</span><span style="color:#E06C75;">(initialCapacity </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> (initialCapacity </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">))</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">sizeCtl</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> cap</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p><h3 id="put-过程分析-1" tabindex="-1"><a class="header-anchor" href="#put-过程分析-1"><span><a href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1">#</a> put 过程分析</span></a></h3><p>仔细地一行一行代码看下去:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> V</span><span style="color:#61AFEF;"> put</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">K</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#E06C75;"> value) {</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#61AFEF;"> putVal</span><span style="color:#E06C75;">(key</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> false</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"><span style="color:#C678DD;">final</span><span style="color:#E5C07B;"> V</span><span style="color:#61AFEF;"> putVal</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">K</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> boolean</span><span style="color:#E06C75;"> onlyIfAbsent) {</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (key </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> ||</span><span style="color:#E06C75;"> value </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) </span><span style="color:#C678DD;">throw</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> NullPointerException</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 得到 hash 值</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> hash </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> spread</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">hashCode</span><span style="color:#ABB2BF;">()</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 用于记录相应链表的长度</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> binCount </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table</span><span style="color:#ABB2BF;">;;</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">        Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> f</span><span style="color:#ABB2BF;">;</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> fh</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 如果数组&quot;空&quot;，进行数组初始化</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> (tab </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> ||</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 初始化数组，后面会详细介绍</span></span>
<span class="line"><span style="color:#E06C75;">            tab </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> initTable</span><span style="color:#E06C75;">()</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 找该 hash 值对应的数组下标，得到第一个节点 f</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> ((f </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> tabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> hash)) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 如果数组该位置为空，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (</span><span style="color:#61AFEF;">casTabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#C678DD;">                         new</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)))</span></span>
<span class="line"><span style="color:#C678DD;">                break</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">                   // no lock when adding to empty bin</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> ((fh </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> f</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> MOVED)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span>
<span class="line"><span style="color:#E06C75;">            tab </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> helpTransfer</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> f)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#E06C75;"> { </span><span style="color:#7F848E;font-style:italic;">// 到这里就是说，f 是该位置的头节点，而且不为空</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">            V</span><span style="color:#E06C75;"> oldVal </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 获取数组该位置的头节点的监视器锁</span></span>
<span class="line"><span style="color:#C678DD;">            synchronized</span><span style="color:#E06C75;"> (f) {</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (</span><span style="color:#61AFEF;">tabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> f) {</span></span>
<span class="line"><span style="color:#C678DD;">                    if</span><span style="color:#E06C75;"> (fh </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) { </span><span style="color:#7F848E;font-style:italic;">// 头节点的 hash 值大于 0，说明是链表</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 用于累加，记录链表的长度</span></span>
<span class="line"><span style="color:#E06C75;">                        binCount </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 遍历链表</span></span>
<span class="line"><span style="color:#C678DD;">                        for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> f</span><span style="color:#ABB2BF;">;;</span><span style="color:#ABB2BF;"> ++</span><span style="color:#E06C75;">binCount) {</span></span>
<span class="line"><span style="color:#E5C07B;">                            K</span><span style="color:#E06C75;"> ek</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                            // 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span>
<span class="line"><span style="color:#C678DD;">                            if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> ==</span><span style="color:#E06C75;"> hash </span><span style="color:#56B6C2;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E06C75;">                                ((ek </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> key </span><span style="color:#56B6C2;">||</span></span>
<span class="line"><span style="color:#E06C75;">                                 (ek </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> &amp;&amp;</span><span style="color:#E5C07B;"> key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">equals</span><span style="color:#ABB2BF;">(ek)</span><span style="color:#E06C75;">))) {</span></span>
<span class="line"><span style="color:#E06C75;">                                oldVal </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                                if</span><span style="color:#E06C75;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">onlyIfAbsent)</span></span>
<span class="line"><span style="color:#E5C07B;">                                    e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                                break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                            }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                            // 到了链表的最末端，将这个新值放到链表的最后面</span></span>
<span class="line"><span style="color:#E5C07B;">                            Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> pred </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                            if</span><span style="color:#E06C75;"> ((e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">                                pred</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">                                                          value</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                                break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                            }</span></span>
<span class="line"><span style="color:#E06C75;">                        }</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#C678DD;">                    else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (f </span><span style="color:#C678DD;">instanceof</span><span style="color:#E06C75;"> TreeBin) { </span><span style="color:#7F848E;font-style:italic;">// 红黑树</span></span>
<span class="line"><span style="color:#E5C07B;">                        Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        binCount </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 2</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 调用红黑树的插值方法插入新节点</span></span>
<span class="line"><span style="color:#C678DD;">                        if</span><span style="color:#E06C75;"> ((p </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> ((</span><span style="color:#E5C07B;">TreeBin</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">)f)</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">putTreeVal</span><span style="color:#ABB2BF;">(hash, key,</span></span>
<span class="line"><span style="color:#ABB2BF;">                                                       value)</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E06C75;">                            oldVal </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                            if</span><span style="color:#E06C75;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">onlyIfAbsent)</span></span>
<span class="line"><span style="color:#E5C07B;">                                p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        }</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (binCount </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (binCount </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> TREEIFY_THRESHOLD)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    //    具体源码我们就不看了，扩容部分后面说</span></span>
<span class="line"><span style="color:#61AFEF;">                    treeifyBin</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (oldVal </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#C678DD;">                    return</span><span style="color:#E06C75;"> oldVal</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // </span></span>
<span class="line"><span style="color:#61AFEF;">    addCount</span><span style="color:#E06C75;">(</span><span style="color:#D19A66;">1L</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> binCount)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="初始化数组-inittable" tabindex="-1"><a class="header-anchor" href="#初始化数组-inittable"><span><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84-inittable">#</a> 初始化数组: initTable</span></a></h3><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">private</span><span style="color:#C678DD;"> final</span><span style="color:#E5C07B;"> Node</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[] </span><span style="color:#61AFEF;">initTable</span><span style="color:#E06C75;">() {</span></span>
<span class="line"><span style="color:#E5C07B;">    Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] tab</span><span style="color:#ABB2BF;">;</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> sc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#E06C75;"> ((tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> ||</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> ==</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> ((sc </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> sizeCtl) </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E5C07B;">            Thread</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">yield</span><span style="color:#ABB2BF;">();</span><span style="color:#7F848E;font-style:italic;"> // lost initialization race; just spin</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">U</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">compareAndSwapInt</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">, SIZECTL, sc, </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">            try</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> ((tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> ||</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;"> ==</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // DEFAULT_CAPACITY 默认初始容量是 16</span></span>
<span class="line"><span style="color:#C678DD;">                    int</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (sc </span><span style="color:#56B6C2;">&gt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) </span><span style="color:#C678DD;">?</span><span style="color:#E06C75;"> sc </span><span style="color:#C678DD;">:</span><span style="color:#E06C75;"> DEFAULT_CAPACITY</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 初始化数组，长度为 16 或初始化时提供的长度</span></span>
<span class="line"><span style="color:#E5C07B;">                    Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] nt </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[])</span><span style="color:#C678DD;">new</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[n]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 将这个数组赋值给 table，table 是 volatile 的</span></span>
<span class="line"><span style="color:#E06C75;">                    table </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nt</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 如果 n 为 16 的话，那么这里 sc = 12</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 其实就是 0.75 * n</span></span>
<span class="line"><span style="color:#E06C75;">                    sc </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 2</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#E06C75;">            } </span><span style="color:#C678DD;">finally</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span>
<span class="line"><span style="color:#E06C75;">                sizeCtl </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> sc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#C678DD;">            break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> tab</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="链表转红黑树-treeifybin" tabindex="-1"><a class="header-anchor" href="#链表转红黑树-treeifybin"><span><a href="#%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91-treeifybin">#</a> 链表转红黑树: treeifyBin</span></a></h3><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">private</span><span style="color:#C678DD;"> final</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> treeifyBin</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">Node</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[] tab</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> index) {</span></span>
<span class="line"><span style="color:#E5C07B;">    Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> b</span><span style="color:#ABB2BF;">;</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> sc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (tab </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // MIN_TREEIFY_CAPACITY 为 64</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> ((n </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;"> MIN_TREEIFY_CAPACITY)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 后面我们再详细分析这个方法</span></span>
<span class="line"><span style="color:#61AFEF;">            tryPresize</span><span style="color:#E06C75;">(n </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // b 是头节点</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> ((b </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> tabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> index)) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> &amp;&amp;</span><span style="color:#E5C07B;"> b</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> &gt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 加锁</span></span>
<span class="line"><span style="color:#C678DD;">            synchronized</span><span style="color:#E06C75;"> (b) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (</span><span style="color:#61AFEF;">tabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> index) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> b) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 下面就是遍历链表，建立一颗红黑树</span></span>
<span class="line"><span style="color:#E5C07B;">                    TreeNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> hd </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> tl </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                    for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> b</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">                        TreeNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span></span>
<span class="line"><span style="color:#C678DD;">                            new</span><span style="color:#E5C07B;"> TreeNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#D19A66;">                                              null</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                        if</span><span style="color:#E06C75;"> ((</span><span style="color:#E5C07B;">p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">prev</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> tl) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E06C75;">                            hd </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                        else</span></span>
<span class="line"><span style="color:#E5C07B;">                            tl</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        tl </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 将红黑树设置到数组相应位置中</span></span>
<span class="line"><span style="color:#61AFEF;">                    setTabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> index</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> TreeBin</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(hd))</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="扩容-trypresize" tabindex="-1"><a class="header-anchor" href="#扩容-trypresize"><span><a href="#%E6%89%A9%E5%AE%B9-trypresize">#</a> 扩容: tryPresize</span></a></h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p><p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p><p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span>
<span class="line"><span style="color:#C678DD;">private</span><span style="color:#C678DD;"> final</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> tryPresize</span><span style="color:#E06C75;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> size) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> c </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (size </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> (MAXIMUM_CAPACITY </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)) </span><span style="color:#C678DD;">?</span><span style="color:#E06C75;"> MAXIMUM_CAPACITY </span><span style="color:#C678DD;">:</span></span>
<span class="line"><span style="color:#61AFEF;">        tableSizeFor</span><span style="color:#E06C75;">(size </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> (size </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> sc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#E06C75;"> ((sc </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> sizeCtl) </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">        Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table</span><span style="color:#ABB2BF;">;</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> (tab </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> ||</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E06C75;">            n </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (sc </span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> c) </span><span style="color:#C678DD;">?</span><span style="color:#E06C75;"> sc </span><span style="color:#C678DD;">:</span><span style="color:#E06C75;"> c</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">U</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">compareAndSwapInt</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">, SIZECTL, sc, </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                try</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#C678DD;">                    if</span><span style="color:#E06C75;"> (table </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> tab) {</span></span>
<span class="line"><span style="color:#ABB2BF;">                        @</span><span style="color:#E5C07B;">SuppressWarnings</span><span style="color:#E06C75;">(</span><span style="color:#98C379;">&quot;unchecked&quot;</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E5C07B;">                        Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] nt </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[])</span><span style="color:#C678DD;">new</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[n]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        table </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nt</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        sc </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 2</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // 0.75 * n</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#E06C75;">                } </span><span style="color:#C678DD;">finally</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#E06C75;">                    sizeCtl </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> sc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (c </span><span style="color:#56B6C2;">&lt;=</span><span style="color:#E06C75;"> sc </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> MAXIMUM_CAPACITY)</span></span>
<span class="line"><span style="color:#C678DD;">            break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (tab </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> table) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span>
<span class="line"><span style="color:#C678DD;">            int</span><span style="color:#E06C75;"> rs </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> resizeStamp</span><span style="color:#E06C75;">(n)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (sc </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">                Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] nt</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> ((sc </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#E06C75;"> RESIZE_STAMP_SHIFT) </span><span style="color:#56B6C2;">!=</span><span style="color:#E06C75;"> rs </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> sc </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> rs </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 1</span><span style="color:#56B6C2;"> ||</span></span>
<span class="line"><span style="color:#E06C75;">                    sc </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> rs </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> MAX_RESIZERS </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> (nt </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nextTable) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> ||</span></span>
<span class="line"><span style="color:#E06C75;">                    transferIndex </span><span style="color:#56B6C2;">&lt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#C678DD;">                    break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                //    此时 nextTab 不为 null</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">U</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">compareAndSwapInt</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">, SIZECTL, sc, sc </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#61AFEF;">                    transfer</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> nt)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            //     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            //  调用 transfer 方法，此时 nextTab 参数为 null</span></span>
<span class="line"><span style="color:#C678DD;">            else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">U</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">compareAndSwapInt</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">, SIZECTL, sc,</span></span>
<span class="line"><span style="color:#ABB2BF;">                                         (rs </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#ABB2BF;"> RESIZE_STAMP_SHIFT) </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 2</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#61AFEF;">                transfer</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p><p>所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。</p><h3 id="数据迁移-transfer" tabindex="-1"><a class="header-anchor" href="#数据迁移-transfer"><span><a href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB-transfer">#</a> 数据迁移: transfer</span></a></h3><p>下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p><p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p><p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p><p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p><p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">private</span><span style="color:#C678DD;"> final</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> transfer</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">Node</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[] tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> Node</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[] nextTab) {</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> stride</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> ((stride </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (NCPU </span><span style="color:#56B6C2;">&gt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#C678DD;">?</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 3</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">/</span><span style="color:#E06C75;"> NCPU </span><span style="color:#C678DD;">:</span><span style="color:#E06C75;"> n) </span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;"> MIN_TRANSFER_STRIDE)</span></span>
<span class="line"><span style="color:#E06C75;">        stride </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> MIN_TRANSFER_STRIDE</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // subdivide range</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 如果 nextTab 为 null，先进行一次初始化</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> (nextTab </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">        try</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 容量翻倍</span></span>
<span class="line"><span style="color:#E5C07B;">            Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] nt </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">[])</span><span style="color:#C678DD;">new</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[n </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            nextTab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nt</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        } </span><span style="color:#C678DD;">catch</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Throwable</span><span style="color:#E06C75;font-style:italic;"> ex</span><span style="color:#E06C75;">) {      </span><span style="color:#7F848E;font-style:italic;">// try to cope with OOME</span></span>
<span class="line"><span style="color:#E06C75;">            sizeCtl </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> Integer</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">MAX_VALUE</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // nextTable 是 ConcurrentHashMap 中的属性</span></span>
<span class="line"><span style="color:#E06C75;">        nextTable </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nextTab</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span></span>
<span class="line"><span style="color:#E06C75;">        transferIndex </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> nextn </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> nextTab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // ForwardingNode 翻译过来就是正在被迁移的 Node</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //    所以它其实相当于是一个标志。</span></span>
<span class="line"><span style="color:#E5C07B;">    ForwardingNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> fwd </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> ForwardingNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(nextTab)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span>
<span class="line"><span style="color:#C678DD;">    boolean</span><span style="color:#E06C75;"> advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    boolean</span><span style="color:#E06C75;"> finishing </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> false</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // to ensure sweep before committing nextTab</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    /*</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // i 是位置索引，bound 是边界，注意是从后往前</span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#E06C75;"> (</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> bound </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;;</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">        Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> f</span><span style="color:#ABB2BF;">;</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> fh</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 下面这个 while 真的是不好理解</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // advance 为 true 表示可以进行下一个位置的迁移了</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        //   简单理解结局: i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span>
<span class="line"><span style="color:#C678DD;">        while</span><span style="color:#E06C75;"> (advance) {</span></span>
<span class="line"><span style="color:#C678DD;">            int</span><span style="color:#E06C75;"> nextIndex</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> nextBound</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (</span><span style="color:#ABB2BF;">--</span><span style="color:#E06C75;">i </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> bound </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> finishing)</span></span>
<span class="line"><span style="color:#E06C75;">                advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> false</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 将 transferIndex 值赋给 nextIndex</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span>
<span class="line"><span style="color:#C678DD;">            else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> ((nextIndex </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> transferIndex) </span><span style="color:#56B6C2;">&lt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E06C75;">                i </span><span style="color:#56B6C2;">=</span><span style="color:#56B6C2;"> -</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> false</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#C678DD;">            else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">U</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">compareAndSwapInt</span></span>
<span class="line"><span style="color:#E06C75;">                     (</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> TRANSFERINDEX</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> nextIndex</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">                      nextBound </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (nextIndex </span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> stride </span><span style="color:#C678DD;">?</span></span>
<span class="line"><span style="color:#E06C75;">                                   nextIndex </span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;"> stride </span><span style="color:#C678DD;">:</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">))) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span></span>
<span class="line"><span style="color:#E06C75;">                bound </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nextBound</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                i </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nextIndex </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> false</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> (i </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#56B6C2;"> ||</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> n </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> nextn) {</span></span>
<span class="line"><span style="color:#C678DD;">            int</span><span style="color:#E06C75;"> sc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (finishing) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 所有的迁移操作已经完成</span></span>
<span class="line"><span style="color:#E06C75;">                nextTable </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 将新的 nextTab 赋值给 table 属性，完成迁移</span></span>
<span class="line"><span style="color:#E06C75;">                table </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> nextTab</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 重新计算 sizeCtl: n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span>
<span class="line"><span style="color:#E06C75;">                sizeCtl </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">-</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">&gt;&gt;&gt;</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">U</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">compareAndSwapInt</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">, SIZECTL, sc </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> sizeCtl, sc </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">)</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 任务结束，方法退出</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> ((sc </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 2</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">!=</span><span style="color:#61AFEF;"> resizeStamp</span><span style="color:#E06C75;">(n) </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#E06C75;"> RESIZE_STAMP_SHIFT)</span></span>
<span class="line"><span style="color:#C678DD;">                    return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了</span></span>
<span class="line"><span style="color:#E06C75;">                finishing </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                i </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // recheck before commit</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> ((f </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> tabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i)) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E06C75;">            advance </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> casTabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> fwd)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> ((fh </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> f</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> MOVED)</span></span>
<span class="line"><span style="color:#E06C75;">            advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> true</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // already processed</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span>
<span class="line"><span style="color:#C678DD;">            synchronized</span><span style="color:#E06C75;"> (f) {</span></span>
<span class="line"><span style="color:#C678DD;">                if</span><span style="color:#E06C75;"> (</span><span style="color:#61AFEF;">tabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> f) {</span></span>
<span class="line"><span style="color:#E5C07B;">                    Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> ln</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hn</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                    // 头节点的 hash 大于 0，说明是链表的 Node 节点</span></span>
<span class="line"><span style="color:#C678DD;">                    if</span><span style="color:#E06C75;"> (fh </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 需要将链表一分为二，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span>
<span class="line"><span style="color:#C678DD;">                        int</span><span style="color:#E06C75;"> runBit </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> fh </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">                        Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> lastRun </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> f</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                        for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> f</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                            int</span><span style="color:#E06C75;"> b </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> &amp;</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                            if</span><span style="color:#E06C75;"> (b </span><span style="color:#56B6C2;">!=</span><span style="color:#E06C75;"> runBit) {</span></span>
<span class="line"><span style="color:#E06C75;">                                runBit </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> b</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                                lastRun </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                            }</span></span>
<span class="line"><span style="color:#E06C75;">                        }</span></span>
<span class="line"><span style="color:#C678DD;">                        if</span><span style="color:#E06C75;"> (runBit </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#E06C75;">                            ln </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> lastRun</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                            hn </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        }</span></span>
<span class="line"><span style="color:#C678DD;">                        else</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#E06C75;">                            hn </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> lastRun</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                            ln </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        }</span></span>
<span class="line"><span style="color:#C678DD;">                        for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> f</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">!=</span><span style="color:#E06C75;"> lastRun</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                            int</span><span style="color:#E06C75;"> ph </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#ABB2BF;">;</span><span style="color:#E5C07B;"> K</span><span style="color:#E06C75;"> pk </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">;</span><span style="color:#E5C07B;"> V</span><span style="color:#E06C75;"> pv </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                            if</span><span style="color:#E06C75;"> ((ph </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> n) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E06C75;">                                ln </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(ph</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> pk</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> pv</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> ln)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                            else</span></span>
<span class="line"><span style="color:#E06C75;">                                hn </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(ph</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> pk</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> pv</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hn)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 其中的一个链表放在新数组的位置 i</span></span>
<span class="line"><span style="color:#61AFEF;">                        setTabAt</span><span style="color:#E06C75;">(nextTab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> ln)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 另一个链表放在新数组的位置 i+n</span></span>
<span class="line"><span style="color:#61AFEF;">                        setTabAt</span><span style="color:#E06C75;">(nextTab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hn)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span>
<span class="line"><span style="color:#61AFEF;">                        setTabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> fwd)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // advance 设置为 true，代表该位置已经迁移完毕</span></span>
<span class="line"><span style="color:#E06C75;">                        advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#C678DD;">                    else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (f </span><span style="color:#C678DD;">instanceof</span><span style="color:#E06C75;"> TreeBin) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 红黑树的迁移</span></span>
<span class="line"><span style="color:#E5C07B;">                        TreeBin</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> t </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">TreeBin</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;">)f</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">                        TreeNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> lo </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> loTail </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">                        TreeNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> hi </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hiTail </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                        int</span><span style="color:#E06C75;"> lc </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hc </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                        for</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> t</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">first</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                            int</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">                            TreeNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> p </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> TreeNode</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#E06C75;">                                (h</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                            if</span><span style="color:#E06C75;"> ((h </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> n) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">                                if</span><span style="color:#E06C75;"> ((</span><span style="color:#E5C07B;">p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">prev</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> loTail) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E06C75;">                                    lo </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                                else</span></span>
<span class="line"><span style="color:#E5C07B;">                                    loTail</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                                loTail </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">                                ++</span><span style="color:#E06C75;">lc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                            }</span></span>
<span class="line"><span style="color:#C678DD;">                            else</span><span style="color:#E06C75;"> {</span></span>
<span class="line"><span style="color:#C678DD;">                                if</span><span style="color:#E06C75;"> ((</span><span style="color:#E5C07B;">p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">prev</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> hiTail) </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#E06C75;">                                    hi </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">                                else</span></span>
<span class="line"><span style="color:#E5C07B;">                                    hiTail</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                                hiTail </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">                                ++</span><span style="color:#E06C75;">hc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                            }</span></span>
<span class="line"><span style="color:#E06C75;">                        }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 如果一分为二后，节点数小于等于6，那么将红黑树转换回链表</span></span>
<span class="line"><span style="color:#E06C75;">                        ln </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (lc </span><span style="color:#56B6C2;">&lt;=</span><span style="color:#E06C75;"> UNTREEIFY_THRESHOLD) </span><span style="color:#C678DD;">?</span><span style="color:#61AFEF;"> untreeify</span><span style="color:#E06C75;">(lo) </span><span style="color:#C678DD;">:</span></span>
<span class="line"><span style="color:#E06C75;">                            (hc </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) </span><span style="color:#C678DD;">?</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> TreeBin</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(lo) </span><span style="color:#C678DD;">:</span><span style="color:#E06C75;"> t</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                        hn </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (hc </span><span style="color:#56B6C2;">&lt;=</span><span style="color:#E06C75;"> UNTREEIFY_THRESHOLD) </span><span style="color:#C678DD;">?</span><span style="color:#61AFEF;"> untreeify</span><span style="color:#E06C75;">(hi) </span><span style="color:#C678DD;">:</span></span>
<span class="line"><span style="color:#E06C75;">                            (lc </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">) </span><span style="color:#C678DD;">?</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> TreeBin</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">(hi) </span><span style="color:#C678DD;">:</span><span style="color:#E06C75;"> t</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 将 ln 放置在新数组的位置 i</span></span>
<span class="line"><span style="color:#61AFEF;">                        setTabAt</span><span style="color:#E06C75;">(nextTab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> ln)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 将 hn 放置在新数组的位置 i+n</span></span>
<span class="line"><span style="color:#61AFEF;">                        setTabAt</span><span style="color:#E06C75;">(nextTab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> hn)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span>
<span class="line"><span style="color:#61AFEF;">                        setTabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> i</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> fwd)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                        // advance 设置为 true，代表该位置已经迁移完毕</span></span>
<span class="line"><span style="color:#E06C75;">                        advance </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">                    }</span></span>
<span class="line"><span style="color:#E06C75;">                }</span></span>
<span class="line"><span style="color:#E06C75;">            }</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p><p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h3 id="get-过程分析-1" tabindex="-1"><a class="header-anchor" href="#get-过程分析-1"><span><a href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1">#</a> get 过程分析</span></a></h3><p>get 方法从来都是最简单的，这里也不例外:</p><ul><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li><li>根据该位置处结点性质进行相应查找 <ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ul></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E5C07B;"> V</span><span style="color:#61AFEF;"> get</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">Object</span><span style="color:#E06C75;"> key) {</span></span>
<span class="line"><span style="color:#E5C07B;">    Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;">[] tab</span><span style="color:#ABB2BF;">;</span><span style="color:#E5C07B;"> Node</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">;</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> eh</span><span style="color:#ABB2BF;">;</span><span style="color:#E5C07B;"> K</span><span style="color:#E06C75;"> ek</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> spread</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">hashCode</span><span style="color:#ABB2BF;">()</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> ((tab </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> &amp;&amp;</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> tab</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&gt;</span><span style="color:#D19A66;"> 0</span><span style="color:#56B6C2;"> &amp;&amp;</span></span>
<span class="line"><span style="color:#E06C75;">        (e </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> tabAt</span><span style="color:#E06C75;">(tab</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> (n </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> h)) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 判断头节点是否就是我们需要的节点</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> ((eh </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> h) {</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> ((ek </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> key </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> (ek </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> &amp;&amp;</span><span style="color:#E5C07B;"> key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">equals</span><span style="color:#ABB2BF;">(ek)</span><span style="color:#E06C75;">))</span></span>
<span class="line"><span style="color:#C678DD;">                return</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#C678DD;"> if</span><span style="color:#E06C75;"> (eh </span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#E06C75;">)</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span>
<span class="line"><span style="color:#C678DD;">            return</span><span style="color:#E06C75;"> (p </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">find</span><span style="color:#ABB2BF;">(h, key)</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#C678DD;"> ?</span><span style="color:#E5C07B;"> p</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#C678DD;"> :</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 遍历链表</span></span>
<span class="line"><span style="color:#C678DD;">        while</span><span style="color:#E06C75;"> ((e </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> ==</span><span style="color:#E06C75;"> h </span><span style="color:#56B6C2;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E06C75;">                ((ek </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> key </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> (ek </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> &amp;&amp;</span><span style="color:#E5C07B;"> key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">equals</span><span style="color:#ABB2BF;">(ek)</span><span style="color:#E06C75;">)))</span></span>
<span class="line"><span style="color:#C678DD;">                return</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">val</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#D19A66;"> null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p><h2 id="对比总结" tabindex="-1"><a class="header-anchor" href="#对比总结"><span><a href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93">#</a> 对比总结</span></a></h2><ul><li><code>HashTable</code> : 使用了synchronized关键字对put等操作进行加锁;</li><li><code>ConcurrentHashMap JDK1.7</code>: 使用分段锁机制实现;</li><li><code>ConcurrentHashMap JDK1.8</code>: 则使用数组+链表+红黑树数据结构和CAS原子操作实现;</li></ul>`,100)]))}const r=n(o,[["render",e],["__file","JUC 集合之 ConcurrentHashMap 详解.html.vue"]]),i=JSON.parse(`{"path":"/posts/Java/ThreadConcurrency/JUC%20%E9%9B%86%E5%90%88%E4%B9%8B%20ConcurrentHashMap%20%E8%AF%A6%E8%A7%A3.html","title":"JUC 集合之 ConcurrentHashMap 详解","lang":"zh-CN","frontmatter":{"title":"JUC 集合之 ConcurrentHashMap 详解","subtitle":"Java，Java开发，Java 体系","date":"2024-03-07T10:15:26.000Z","category":["Java"],"tag":["Java","Thread","concurrency"],"order":14,"description":"DK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap；本文将分别介绍这两种方式的实现方案及其区别。 JUC 集合之 ConcurrentHashMap 详解 带着BAT大厂的面试问题去理解 为什么HashTable慢 Concurrent...","head":[["meta",{"property":"og:url","content":"https://cactusli.net/posts/Java/ThreadConcurrency/JUC%20%E9%9B%86%E5%90%88%E4%B9%8B%20ConcurrentHashMap%20%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"Cactus's Blog"}],["meta",{"property":"og:title","content":"JUC 集合之 ConcurrentHashMap 详解"}],["meta",{"property":"og:description","content":"DK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap；本文将分别介绍这两种方式的实现方案及其区别。 JUC 集合之 ConcurrentHashMap 详解 带着BAT大厂的面试问题去理解 为什么HashTable慢 Concurrent..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://lixuanfengs.github.io/blog-images/vp/Java/java-thread-x-concurrent-hashmap-1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-08T03:51:56.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Thread"}],["meta",{"property":"article:tag","content":"concurrency"}],["meta",{"property":"article:published_time","content":"2024-03-07T10:15:26.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-08T03:51:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC 集合之 ConcurrentHashMap 详解\\",\\"image\\":[\\"https://lixuanfengs.github.io/blog-images/vp/Java/java-thread-x-concurrent-hashmap-1.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/java-thread-x-concurrent-hashmap-2.png\\"],\\"datePublished\\":\\"2024-03-07T10:15:26.000Z\\",\\"dateModified\\":\\"2024-03-08T03:51:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cactus li\\",\\"url\\":\\"https://cactusli.net\\"}]}"]]},"headers":[{"level":2,"title":"# 带着BAT大厂的面试问题去理解","slug":"带着bat大厂的面试问题去理解","link":"#带着bat大厂的面试问题去理解","children":[]},{"level":2,"title":"# 为什么HashTable慢","slug":"为什么hashtable慢","link":"#为什么hashtable慢","children":[]},{"level":2,"title":"# ConcurrentHashMap - JDK 1.7","slug":"concurrenthashmap-jdk-1-7","link":"#concurrenthashmap-jdk-1-7","children":[{"level":3,"title":"# 数据结构","slug":"数据结构","link":"#数据结构","children":[]},{"level":3,"title":"# 初始化","slug":"初始化","link":"#初始化","children":[]},{"level":3,"title":"# put 过程分析","slug":"put-过程分析","link":"#put-过程分析","children":[]},{"level":3,"title":"# 初始化槽: ensureSegment","slug":"初始化槽-ensuresegment","link":"#初始化槽-ensuresegment","children":[]},{"level":3,"title":"# 获取写入锁: scanAndLockForPut","slug":"获取写入锁-scanandlockforput","link":"#获取写入锁-scanandlockforput","children":[]},{"level":3,"title":"# 扩容: rehash","slug":"扩容-rehash","link":"#扩容-rehash","children":[]},{"level":3,"title":"# get 过程分析","slug":"get-过程分析","link":"#get-过程分析","children":[]},{"level":3,"title":"# 并发问题分析","slug":"并发问题分析","link":"#并发问题分析","children":[]}]},{"level":2,"title":"# ConcurrentHashMap - JDK 1.8","slug":"concurrenthashmap-jdk-1-8","link":"#concurrenthashmap-jdk-1-8","children":[{"level":3,"title":"# 数据结构","slug":"数据结构-1","link":"#数据结构-1","children":[]},{"level":3,"title":"# 初始化","slug":"初始化-1","link":"#初始化-1","children":[]},{"level":3,"title":"# put 过程分析","slug":"put-过程分析-1","link":"#put-过程分析-1","children":[]},{"level":3,"title":"# 初始化数组: initTable","slug":"初始化数组-inittable","link":"#初始化数组-inittable","children":[]},{"level":3,"title":"# 链表转红黑树: treeifyBin","slug":"链表转红黑树-treeifybin","link":"#链表转红黑树-treeifybin","children":[]},{"level":3,"title":"# 扩容: tryPresize","slug":"扩容-trypresize","link":"#扩容-trypresize","children":[]},{"level":3,"title":"# 数据迁移: transfer","slug":"数据迁移-transfer","link":"#数据迁移-transfer","children":[]},{"level":3,"title":"# get 过程分析","slug":"get-过程分析-1","link":"#get-过程分析-1","children":[]}]},{"level":2,"title":"# 对比总结","slug":"对比总结","link":"#对比总结","children":[]}],"git":{"createdTime":1709869916000,"updatedTime":1709869916000,"contributors":[{"name":"lixuanfengs","email":"1183895890@qq.com","commits":1}]},"readingTime":{"minutes":31.2,"words":9359},"filePathRelative":"posts/Java/ThreadConcurrency/JUC 集合之 ConcurrentHashMap 详解.md","localizedDate":"2024年3月7日","excerpt":"<blockquote>\\n<p>DK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap；本文将分别介绍这两种方式的实现方案及其区别。</p>\\n</blockquote>\\n<ul>\\n<li>JUC 集合之 ConcurrentHashMap 详解\\n<ul>\\n<li><a href=\\"#%E5%B8%A6%E7%9D%80bat%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8E%BB%E7%90%86%E8%A7%A3\\">带着BAT大厂的面试问题去理解</a></li>\\n<li><a href=\\"#%E4%B8%BA%E4%BB%80%E4%B9%88hashtable%E6%85%A2\\">为什么HashTable慢</a></li>\\n<li>ConcurrentHashMap - JDK 1.7\\n<ul>\\n<li><a href=\\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\\">数据结构</a></li>\\n<li><a href=\\"#%E5%88%9D%E5%A7%8B%E5%8C%96\\">初始化</a></li>\\n<li><a href=\\"#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90\\">put 过程分析</a></li>\\n<li><a href=\\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A7%BD-ensuresegment\\">初始化槽: ensureSegment</a></li>\\n<li><a href=\\"#%E8%8E%B7%E5%8F%96%E5%86%99%E5%85%A5%E9%94%81-scanandlockforput\\">获取写入锁: scanAndLockForPut</a></li>\\n<li><a href=\\"#%E6%89%A9%E5%AE%B9-rehash\\">扩容: rehash</a></li>\\n<li><a href=\\"#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90\\">get 过程分析</a></li>\\n<li><a href=\\"#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\\">并发问题分析</a></li>\\n</ul>\\n</li>\\n<li>ConcurrentHashMap - JDK 1.8\\n<ul>\\n<li><a href=\\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1\\">数据结构</a></li>\\n<li><a href=\\"#%E5%88%9D%E5%A7%8B%E5%8C%96-1\\">初始化</a></li>\\n<li><a href=\\"#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1\\">put 过程分析</a></li>\\n<li><a href=\\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84-inittable\\">初始化数组: initTable</a></li>\\n<li><a href=\\"#%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91-treeifybin\\">链表转红黑树: treeifyBin</a></li>\\n<li><a href=\\"#%E6%89%A9%E5%AE%B9-trypresize\\">扩容: tryPresize</a></li>\\n<li><a href=\\"#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB-transfer\\">数据迁移: transfer</a></li>\\n<li><a href=\\"#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1\\">get 过程分析</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93\\">对比总结</a></li>\\n<li><a href=\\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\\">参考文章</a></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{r as comp,i as data};
