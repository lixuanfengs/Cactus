import{_ as p,e as o,o as t,c,b as a,g as s,f as e,h as l}from"./app-B_yijj-t.js";const r={},i=l(`<blockquote><p>本文主要对LinkedHashSet&amp;Map 源码解析。</p></blockquote><ul><li>LinkedHashSet&amp;Map 源码解析 <ul><li>Java 7 - LinkedHashSet&amp;Map <ul><li><a href="#%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D">总体介绍</a></li><li>方法剖析 <ul><li><a href="#get">get()</a></li><li><a href="#put">put()</a></li><li><a href="#remove">remove()</a></li></ul></li><li><a href="#linkedhashset">LinkedHashSet</a></li><li><a href="#linkedhashmap%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95">LinkedHashMap经典用法</a></li></ul></li></ul></li></ul><h2 id="java-7-linkedhashset-map" tabindex="-1"><a class="header-anchor" href="#java-7-linkedhashset-map"><span><a href="#java-7-linkedhashset-map">#</a> Java 7 - LinkedHashSet&amp;Map</span></a></h2><h3 id="总体介绍" tabindex="-1"><a class="header-anchor" href="#总体介绍"><span><a href="#%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D">#</a> 总体介绍</span></a></h3><p>如果你已看过前面关于<em>HashSet</em>和<em>HashMap</em>，以及<em>TreeSet</em>和<em>TreeMap</em>的讲解，一定能够想到本文将要讲解的<em>LinkedHashSet</em>和<em>LinkedHashMap</em>其实也是一回事。<em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong>LinkedHashSet里面有一个LinkedHashMap(适配器模式)</strong>。因此本文将重点分析<em>LinkedHashMap</em>。</p><p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。<strong>可将*LinkedHashMap*看作采用*linked list*增强的*HashMap*。</strong></p><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/LinkedHashMap_base.png" alt="LinkedHashMap_base.png" tabindex="0" loading="lazy"><figcaption>LinkedHashMap_base.png</figcaption></figure><p>事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，<strong>二者唯一的区别是*LinkedHashMap*在*HashMap*的基础上，采用双向链表(doubly-linked list)的形式将所有<code>entry</code>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了<code>header</code>指向双向链表的头部(是一个哑元)，<strong>该双向链表的迭代顺序就是<code>entry</code>的插入顺序</strong>。</p><p>除了可以保迭代历顺序，这种结构还有一个好处 : <strong>迭代*LinkedHashMap*时不需要像*HashMap*那样遍历整个<code>table</code>，而只需要直接遍历<code>header</code>指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p><p>有两个参数可以影响<em>LinkedHashMap</em>的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</p><p>通过如下方式可以得到一个跟源<em>Map</em> <strong>迭代顺序</strong>一样的<em>LinkedHashMap</em>:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">void</span><span style="color:#61AFEF;"> foo</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">Map</span><span style="color:#E06C75;"> m) {</span></span>
<span class="line"><span style="color:#E5C07B;">    Map</span><span style="color:#E06C75;"> copy </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> LinkedHashMap</span><span style="color:#E06C75;">(m)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    ...</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>出于性能原因，<em>LinkedHashMap</em>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成(wrapped)同步的:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="方法剖析" tabindex="-1"><a class="header-anchor" href="#方法剖析"><span><a href="#%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90">#</a> 方法剖析</span></a></h3><h4 id="get" tabindex="-1"><a class="header-anchor" href="#get"><span><a href="#get">#</a> get()</span></a></h4>`,17),d=a("code",null,"get(Object key)",-1),y=a("code",null,"key",-1),B=a("code",null,"value",-1),h=a("code",null,"HashMap.get()",-1),E={href:"https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet",target:"_blank",rel:"noopener noreferrer"},v={href:"http://HashMap.md#get",target:"_blank",rel:"noopener noreferrer"},m=l(`<h4 id="put" tabindex="-1"><a class="header-anchor" href="#put"><span><a href="#put">#</a> put()</span></a></h4><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p><p>注意，这里的<strong>插入有两重含义</strong>:</p><blockquote><ol><li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol></blockquote><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/LinkedHashMap_addEntry.png" alt="LinkedHashMap_addEntry.png" tabindex="0" loading="lazy"><figcaption>LinkedHashMap_addEntry.png</figcaption></figure><p><code>addEntry()</code>代码如下:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// LinkedHashMap.addEntry()</span></span>
<span class="line"><span style="color:#C678DD;">void</span><span style="color:#61AFEF;"> addEntry</span><span style="color:#E06C75;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;"> hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> K</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> bucketIndex) {</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#E06C75;"> ((size </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> threshold) </span><span style="color:#56B6C2;">&amp;&amp;</span><span style="color:#E06C75;"> (</span><span style="color:#D19A66;">null</span><span style="color:#56B6C2;"> !=</span><span style="color:#E06C75;"> table[bucketIndex])) {</span></span>
<span class="line"><span style="color:#61AFEF;">        resize</span><span style="color:#E06C75;">(</span><span style="color:#D19A66;">2</span><span style="color:#56B6C2;"> *</span><span style="color:#E5C07B;"> table</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">// 自动扩容，并重新哈希</span></span>
<span class="line"><span style="color:#E06C75;">        hash </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (</span><span style="color:#D19A66;">null</span><span style="color:#56B6C2;"> !=</span><span style="color:#E06C75;"> key) </span><span style="color:#C678DD;">?</span><span style="color:#61AFEF;"> hash</span><span style="color:#E06C75;">(key) </span><span style="color:#C678DD;">:</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        bucketIndex </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> hash </span><span style="color:#56B6C2;">&amp;</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">table</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;">1</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">// hash%table.length</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 1.在冲突链表头部插入新的entry</span></span>
<span class="line"><span style="color:#E5C07B;">    HashMap</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">Entry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> old </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table[bucketIndex]</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    Entry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> Entry</span><span style="color:#ABB2BF;">&lt;&gt;</span><span style="color:#E06C75;">(hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> key</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> value</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> old)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    table[bucketIndex] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 2.在双向链表的尾部插入新的entry</span></span>
<span class="line"><span style="color:#E5C07B;">    e</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">addBefore</span><span style="color:#ABB2BF;">(header);</span></span>
<span class="line"><span style="color:#E06C75;">    size</span><span style="color:#ABB2BF;">++;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表头引用<code>header</code>的前面，这样<code>e</code>就成为双向链表中的最后一个元素。<code>addBefore()</code>的代码如下:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></span>
<span class="line"><span style="color:#C678DD;">private</span><span style="color:#C678DD;"> void</span><span style="color:#61AFEF;"> addBefore</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">Entry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#E06C75;"> existingEntry) {</span></span>
<span class="line"><span style="color:#E06C75;">    after  </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> existingEntry</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    before </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> existingEntry</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">before</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    before</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">after</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> this</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">    after</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">before</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> this</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码只是简单修改相关<code>entry</code>的引用而已。</p><h4 id="remove" tabindex="-1"><a class="header-anchor" href="#remove"><span><a href="#remove">#</a> remove()</span></a></h4><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的<strong>删除也有两重含义</strong>:</p><blockquote><ol><li>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><figure><img src="https://lixuanfengs.github.io/blog-images/vp/Java/LinkedHashMap_removeEntryForKey.png" alt="LinkedHashMap_removeEntryForKey.png" tabindex="0" loading="lazy"><figcaption>LinkedHashMap_removeEntryForKey.png</figcaption></figure><p><code>removeEntryForKey()</code>对应的代码如下:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></span>
<span class="line"><span style="color:#C678DD;">final</span><span style="color:#E5C07B;"> Entry</span><span style="color:#56B6C2;">&lt;</span><span style="color:#E06C75;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">V</span><span style="color:#56B6C2;">&gt;</span><span style="color:#61AFEF;"> removeEntryForKey</span><span style="color:#E06C75;">(</span><span style="color:#E5C07B;">Object</span><span style="color:#E06C75;"> key) {</span></span>
<span class="line"><span style="color:#ABB2BF;">	......</span></span>
<span class="line"><span style="color:#C678DD;">	int</span><span style="color:#E06C75;"> hash </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> (key </span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) </span><span style="color:#C678DD;">?</span><span style="color:#D19A66;"> 0</span><span style="color:#C678DD;"> :</span><span style="color:#61AFEF;"> hash</span><span style="color:#E06C75;">(key)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#E06C75;"> i </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> indexFor</span><span style="color:#E06C75;">(hash</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> table</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">length</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">// hash&amp;(table.length-1)</span></span>
<span class="line"><span style="color:#E5C07B;">    Entry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> prev </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> table[i]</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">// 得到冲突链表</span></span>
<span class="line"><span style="color:#E5C07B;">    Entry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> prev</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#E06C75;"> (e </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#E06C75;">) {</span><span style="color:#7F848E;font-style:italic;">// 遍历冲突链表</span></span>
<span class="line"><span style="color:#E5C07B;">        Entry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#E06C75;"> next </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">        Object</span><span style="color:#E06C75;"> k</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#E06C75;"> (</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">hash</span><span style="color:#56B6C2;"> ==</span><span style="color:#E06C75;"> hash </span><span style="color:#56B6C2;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E06C75;">            ((k </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">key</span><span style="color:#E06C75;">) </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> key </span><span style="color:#56B6C2;">||</span><span style="color:#E06C75;"> (key </span><span style="color:#56B6C2;">!=</span><span style="color:#D19A66;"> null</span><span style="color:#56B6C2;"> &amp;&amp;</span><span style="color:#E5C07B;"> key</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">equals</span><span style="color:#ABB2BF;">(k)</span><span style="color:#E06C75;">))) {</span><span style="color:#7F848E;font-style:italic;">// 找到要删除的entry</span></span>
<span class="line"><span style="color:#E06C75;">            modCount</span><span style="color:#ABB2BF;">++;</span><span style="color:#E06C75;"> size</span><span style="color:#ABB2BF;">--;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 1. 将e从对应bucket的冲突链表中删除</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> (prev </span><span style="color:#56B6C2;">==</span><span style="color:#E06C75;"> e) table[i] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            else</span><span style="color:#E5C07B;"> prev</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">next</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 2. 将e从双向链表中删除</span></span>
<span class="line"><span style="color:#E5C07B;">            e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">before</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">after</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">after</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">            e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">after</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">before</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> e</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">before</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">            return</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">        }</span></span>
<span class="line"><span style="color:#E06C75;">        prev </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span><span style="color:#E06C75;"> e </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> next</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> e</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset"><span><a href="#linkedhashset">#</a> LinkedHashSet</span></a></h3><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#C678DD;"> class</span><span style="color:#E5C07B;"> LinkedHashSet</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">E</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;">    extends</span><span style="color:#E5C07B;"> HashSet</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">E</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;">    implements</span><span style="color:#E5C07B;"> Set</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">E</span><span style="color:#ABB2BF;">&gt;,</span><span style="color:#E5C07B;"> Cloneable</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> java.io.</span><span style="color:#E5C07B;">Serializable</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    ......</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // LinkedHashSet里面有一个LinkedHashMap</span></span>
<span class="line"><span style="color:#C678DD;">    public</span><span style="color:#61AFEF;"> LinkedHashSet</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;font-style:italic;"> initialCapacity</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">float</span><span style="color:#E06C75;font-style:italic;"> loadFactor</span><span style="color:#ABB2BF;">)</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">        map </span><span style="color:#56B6C2;">=</span><span style="color:#C678DD;"> new</span><span style="color:#E5C07B;"> LinkedHashMap</span><span style="color:#ABB2BF;">&lt;&gt;(initialCapacity, loadFactor);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">	......</span></span>
<span class="line"><span style="color:#C678DD;">    public</span><span style="color:#C678DD;"> boolean</span><span style="color:#61AFEF;"> add</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">E</span><span style="color:#E06C75;font-style:italic;"> e</span><span style="color:#ABB2BF;">)</span><span style="color:#ABB2BF;"> {</span><span style="color:#7F848E;font-style:italic;">//简单的方法转换</span></span>
<span class="line"><span style="color:#C678DD;">        return</span><span style="color:#E5C07B;"> map</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">put</span><span style="color:#ABB2BF;">(e, PRESENT)</span><span style="color:#56B6C2;">==</span><span style="color:#D19A66;">null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">    ......</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="linkedhashmap经典用法" tabindex="-1"><a class="header-anchor" href="#linkedhashmap经典用法"><span><a href="#linkedhashmap%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95">#</a> LinkedHashMap经典用法</span></a></h3><p><em>LinkedHashMap</em>除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回<code>true</code>，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/** 一个固定大小的FIFO替换策略的缓存 */</span></span>
<span class="line"><span style="color:#C678DD;">class</span><span style="color:#E5C07B;"> FIFOCache</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#C678DD;"> extends</span><span style="color:#E5C07B;"> LinkedHashMap</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;"> V</span><span style="color:#ABB2BF;">&gt;{</span></span>
<span class="line"><span style="color:#C678DD;">    private</span><span style="color:#C678DD;"> final</span><span style="color:#C678DD;"> int</span><span style="color:#E06C75;"> cacheSize</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    public</span><span style="color:#61AFEF;"> FIFOCache</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">int</span><span style="color:#E06C75;font-style:italic;"> cacheSize</span><span style="color:#ABB2BF;">){</span></span>
<span class="line"><span style="color:#E5C07B;">        this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">cacheSize</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> cacheSize;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 当Entry个数超过cacheSize时，删除最老的Entry</span></span>
<span class="line"><span style="color:#ABB2BF;">    @</span><span style="color:#E5C07B;">Override</span></span>
<span class="line"><span style="color:#C678DD;">    protected</span><span style="color:#C678DD;"> boolean</span><span style="color:#61AFEF;"> removeEldestEntry</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">Map</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">Entry</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">K</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">V</span><span style="color:#ABB2BF;">&gt; </span><span style="color:#E06C75;font-style:italic;">eldest</span><span style="color:#ABB2BF;">)</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">       return</span><span style="color:#61AFEF;"> size</span><span style="color:#ABB2BF;">() </span><span style="color:#56B6C2;">&gt;</span><span style="color:#ABB2BF;"> cacheSize;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,23);function C(u,b){const n=o("ExternalLinkIcon");return t(),c("div",null,[i,a("p",null,[d,s("方法根据指定的"),y,s("值返回对应的"),B,s("。该方法跟"),h,s("方法的流程几乎完全一样，读者可自行[参考前文在新窗口打开]("),a("a",E,[s("https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet"),e(n)]),s(" and "),a("a",v,[s("HashMap.md#get"),e(n)]),s(")，这里不再赘述。")]),m])}const k=p(r,[["render",C],["__file","LinkedHashSet_Map 源码解析.html.vue"]]),g=JSON.parse(`{"path":"/posts/Java/Collection/LinkedHashSet_Map%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html","title":"LinkedHashSet&Map 源码解析","lang":"zh-CN","frontmatter":{"title":"LinkedHashSet&Map 源码解析","subtitle":"Java，Java开发，Java 体系","date":"2024-03-06T10:15:26.000Z","category":["Java"],"tag":["Java","Collection"],"order":7,"description":"本文主要对LinkedHashSet&Map 源码解析。 LinkedHashSet&Map 源码解析 Java 7 - LinkedHashSet&Map 总体介绍 方法剖析 get() put() remove() LinkedHashSet LinkedHashMap经典用法 # Java 7 - LinkedHashSet&Map # 总体介绍...","head":[["meta",{"property":"og:url","content":"https://cactusli.net/posts/Java/Collection/LinkedHashSet_Map%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"Cactus's Blog"}],["meta",{"property":"og:title","content":"LinkedHashSet&Map 源码解析"}],["meta",{"property":"og:description","content":"本文主要对LinkedHashSet&Map 源码解析。 LinkedHashSet&Map 源码解析 Java 7 - LinkedHashSet&Map 总体介绍 方法剖析 get() put() remove() LinkedHashSet LinkedHashMap经典用法 # Java 7 - LinkedHashSet&Map # 总体介绍..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://lixuanfengs.github.io/blog-images/vp/Java/LinkedHashMap_base.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-08T03:51:56.000Z"}],["meta",{"property":"article:author","content":"Cactus li"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Collection"}],["meta",{"property":"article:published_time","content":"2024-03-06T10:15:26.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-08T03:51:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LinkedHashSet&Map 源码解析\\",\\"image\\":[\\"https://lixuanfengs.github.io/blog-images/vp/Java/LinkedHashMap_base.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/LinkedHashMap_addEntry.png\\",\\"https://lixuanfengs.github.io/blog-images/vp/Java/LinkedHashMap_removeEntryForKey.png\\"],\\"datePublished\\":\\"2024-03-06T10:15:26.000Z\\",\\"dateModified\\":\\"2024-03-08T03:51:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cactus li\\",\\"url\\":\\"https://cactusli.net\\"}]}"]]},"headers":[{"level":2,"title":"# Java 7 - LinkedHashSet&Map","slug":"java-7-linkedhashset-map","link":"#java-7-linkedhashset-map","children":[{"level":3,"title":"# 总体介绍","slug":"总体介绍","link":"#总体介绍","children":[]},{"level":3,"title":"# 方法剖析","slug":"方法剖析","link":"#方法剖析","children":[]},{"level":3,"title":"# LinkedHashSet","slug":"linkedhashset","link":"#linkedhashset","children":[]},{"level":3,"title":"# LinkedHashMap经典用法","slug":"linkedhashmap经典用法","link":"#linkedhashmap经典用法","children":[]}]}],"git":{"createdTime":1709869916000,"updatedTime":1709869916000,"contributors":[{"name":"lixuanfengs","email":"1183895890@qq.com","commits":1}]},"readingTime":{"minutes":6.39,"words":1917},"filePathRelative":"posts/Java/Collection/LinkedHashSet&Map 源码解析.md","localizedDate":"2024年3月6日","excerpt":"<blockquote>\\n<p>本文主要对LinkedHashSet&amp;Map 源码解析。</p>\\n</blockquote>\\n<ul>\\n<li>LinkedHashSet&amp;Map 源码解析\\n<ul>\\n<li>Java 7 - LinkedHashSet&amp;Map\\n<ul>\\n<li><a href=\\"#%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D\\">总体介绍</a></li>\\n<li>方法剖析\\n<ul>\\n<li><a href=\\"#get\\">get()</a></li>\\n<li><a href=\\"#put\\">put()</a></li>\\n<li><a href=\\"#remove\\">remove()</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#linkedhashset\\">LinkedHashSet</a></li>\\n<li><a href=\\"#linkedhashmap%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95\\">LinkedHashMap经典用法</a></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{k as comp,g as data};
